{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Java full stack El siguiente documento se compone del material facilitado para el desarrollo del curso de Java Full Stack Trainne","title":"Home"},{"location":"#java-full-stack","text":"El siguiente documento se compone del material facilitado para el desarrollo del curso de Java Full Stack Trainne","title":"Java full stack"},{"location":"modulos/mod_4/mod4_uni001/","text":"Unidad 1: Introducci\u00f3n a Java Servlets y JSP Introducci\u00f3n a Java Servlets y JSP - Parte I Competencias Conocer herramientas involucradas. Instalar el kit de desarrollo de java (JDK) en mac. Instalar el kit de desarrollo de java (JDK) en Windows. Conocer e instalar el entorno de desarrollo Eclipse. Conocer e instalar el contenedor web Apache. Comprobar el correcto funcionamiento del servidor Tomcat . Introducci\u00f3n Para comenzar con las labores de desarrollo es necesario contar con un ambiente perfectamente instalado y con\ufb01gurado para poder trabajar de forma c\u00f3moda y productiva. El stack de tecnolog\u00edas que utilizaremos se pueden observar en la imagen 1. JDK instalaci\u00f3n La JDK ( Java Developed Kit ) es la biblioteca esencial de java. Nos proporciona la biblioteca de clases java, la Java Virtual Machine , el compilador, documentaci\u00f3n, entre otros. Para instalarlo en cualquier entorno ya sea mac, Windows o Linux, primero hay que descargarla desde la pagina web o\ufb01cial. \u00bfQu\u00e9 paquete Java necesito? Desarrolladores de software: JDK (Java SE Development Kit) Para desarrolladores de Java. Incluye un JRE completo m\u00e1s herramientas para desarrollar, depurar y monitoreo de aplicaciones Java. Administradores que ejecutan aplicaciones en un servidor: Servidor JRE (Server Java Runtime Environment) Para desplegar aplicaciones Java en servidores. Incluye herramientas para el monitoreo de JVM y herramientas com\u00fanmente requeridas para aplicaciones de servidor, pero no incluye integraci\u00f3n de navegador (el complemento de Java), actualizaci\u00f3n autom\u00e1tica ni un instalador. Usuario \ufb01nal que ejecuta Java en un escritorio: JRE (Java Runtime Environment) . Cubre la mayor\u00eda de las necesidades de los usuarios \ufb01nales. Contiene todo lo necesario para ejecutar aplicaciones Java en su sistema. Instalaci\u00f3n JDK en MAC El primer paso es descargar el jdk desde el link adjunto. Nos mostrar\u00e1 una p\u00e1gina con las opciones de descarga: Seleccionamos la versi\u00f3n correspondiente a la de nuestro sistema operativo. En caso de utilizar mac obtendr\u00e1s el archivo jdk-8u201-macosx-x64.dgm . Para instalar solamente ejecuta el archivo .dmg y sigue las instrucciones siguiente siguiente para terminar con la instalaci\u00f3n. En mac no es necesario con\ufb01gurar variables de entorno. Para veri\ufb01car la versi\u00f3n del jdk que tenemos instalada, abre una consola e ingresa el comando java \u2013versi\u00f3n . \u279c java -version java version \"1.8.0_181\" Java(TM) SE Runtime Environment (build 1.8.0_181-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode) En caso de no tener el JDK, la consola lanzar\u00e1 un error indicando que no se encuentra el java developer kit . Instalaci\u00f3n JDK en Windows Plataformas: Windows 2008 Server Windows 7 Windows 8 Windows XP Windows Server 2012 Windows Vista Windows 10. Veri\ufb01car la instalaci\u00f3n actual en tu Windows. Abrir una ventana CMD utilizando el men\u00fa contextual. Ejecutar: java -version javac -version Si esto no funciona, se debe descargar el JDK indicado para el sistema operativo que se posee en el siguiente link Instalaci\u00f3n de ide Eclipse Para el correcto seguimiento de los ejercicios utilizaremos Eclipse, ide para java con muchas caracter\u00edsticas que lo hacen uno de los m\u00e1s usados. Es multiplataforma por estar escrito en java, y solo hay que descargarlo y dejarlo en una ubicaci\u00f3n en tu equipo. Perfectamente podr\u00edas utilizar otro ide como netbeans o intellij, pero correr\u00eda por tu cuenta su funcionamiento particular. Para descargar el ide, dirigirse a la p\u00e1gina de descargas de Eclipse . Esperar a que la descarga se complete. Terminar\u00e1s con un archivo comprimido, el cual,se debe ubicar en alguna carpeta de tu equipo a elecci\u00f3n. Se sugiere crear una carpeta independiente para el ide. Dentro de archivo de descarga ver\u00e1s un icono de Eclipse, el cual debes ejecutar con doble click. Con esa acci\u00f3n basta para ejecutar el ide. Para los equipos mac, el archivo descargado es de tipo .dmg y para Windows el archivo es de tipo .exe. Al ejecutar el instalador, se nos mostrar\u00e1 una pantalla en donde nos pide seleccionar la versi\u00f3n de Eclipse que deseamos instalar. En este caso debemos pinchar la opci\u00f3n de Eclipse IDE for java EE developers \ud83d\udc40. Esta versi\u00f3n es la indicada para programar con Java Enterprise Edition. Instalaci\u00f3n del contenedor Apache En esta etapa debemos instalar el servidor que har\u00e1 que las aplicaciones puedan ejecutarse en entorno local . El contenedor de aplicaciones es el software que otorga los servicios necesarios a los artefactos que generamos en este curso, y en esta ocasi\u00f3n utilizaremos el contenedor de servlets Apache Tomcat . Debemos entonces descargar el contenedor desde la siguiente URL . En la ventana, en la secci\u00f3n de nombre Binary Distributions descargamos desde la secci\u00f3n Core la versi\u00f3n del comprimido de Tomcat. Descargar el archivo zip (pgp, sha512) y crear en una carpeta de nombre contenedor en nuestro equipo. Se recomienda dejar la carpeta en C:/ en Windows, o en Aplicaciones en mac. El archivo descargado es un archivo comprimido que debemos descomprimir en la carpeta reci\u00e9n creada. Tanto en Mac como en Windows, el contenido de la carpeta no var\u00eda , manteniendo la misma estructura de carpetas. En este ejemplo se muestra la ubicaci\u00f3n en un equipo Mac. Teniendo en nuestro poder el contenedor Tomcat, es tiempo de con\ufb01gurarlo. Cabe decir que existen dos formas de con\ufb01guraci\u00f3n en un entorno de desarrollo. Con\ufb01gurado directamente en Eclipse. Con\ufb01gurado de forma manual en el equipo. Con\ufb01guraremos el contenedor directamente en Eclipse , ya que nos evita tener que ejecutar con\ufb01guraciones extras que si tendr\u00edamos que hacer en una con\ufb01guraci\u00f3n est\u00e1ndar. Otra ventaja que Eclipse integra una vista de servidores la cual nos permite levantar, apagar, limpiar y dar mantenci\u00f3n al contenedor Tomcat. De forma manual todas estas acciones b\u00e1sicas deben hacerse mediante consola de comandos. En la secci\u00f3n de proyectos, ejecutamos command + n y escribimos server . Esto nos lleva a la secci\u00f3n de configuraci\u00f3n de servidores para eclipse. La versi\u00f3n descargada fue la 9.0.31 , es por eso que debemos ir a: Apache -> Tomcat v9.0 Server Luego, debemos indicar donde se encuentra nuestro Apache Tomcat , en mi caso est\u00e1 en aplicaciones, dentro de una carpeta llamada contenedor . /Applications/contenedor/apache-tomcat-9.0.31 . Se recomienda seleccionar el JDK versi\u00f3n 1.8, por defecto para evitar en el caso que tengamos otra instalaci\u00f3n que se ejecute nuestro server en un JDK que no queremos. Al \ufb01nalizar, Eclipse enlazara el servidor Tomcat a la vista de servidores de Eclipse. Para poder probar si es que tenemos el servidor bien configurado nos vamos a la perspectiva WEB , y en la pesta\u00f1a servers, presionamos play. Adicional a esto, podremos crear una prueba, para poder comprobar el correcto servicio de Apache Tomcat . Es por esto que vamos a crear un proyecto de web din\u00e1mica. Dejamos las configuraciones por defecto, aunque para este caso se escoge la opci\u00f3n de la configuraci\u00f3n por defecto de Apache Tomcat 9.0. En /proyectoPrueba/WebContent/ , creamos un index.html . Luego ejecutamos desde el servidor, no como aplicaci\u00f3n. Con esto deber\u00edamos tener nuestra web funcionando correctamente. Contenedor Tomcat Competencias Conocer caracter\u00edsticas del contenedor Tomcat Desplegar aplicaciones en Tomcat Con\ufb01gurar puerto de funcionamiento Introducci\u00f3n El software Apache Tomcat es una implementaci\u00f3n de c\u00f3digo abierto de: Java Servlet JavaServer Pages Java Expression Language Java WebSocket. Las especi\ufb01caciones de Java Servlet, JavaServer Pages, Java Expression Language y Java WebSocket se desarrollan bajo el Proceso de la Comunidad Java. Tomcat cumple la funci\u00f3n de contenedor de servlets y est\u00e1 desarrollado en java, lo que signi\ufb01ca que puede correr en distintas arquitecturas , ya sea windows, linux o mac, siempre y cuando exista una m\u00e1quina virtual instalada . Aparte de ser un contenedor de servlets, tambi\u00e9n es un servidor web , por lo cual es posible subir sitios web din\u00e1micos a su infraestructura. Estructura Para conocer el funcionamiento de Tomcat, es necesario conocer su estructura de carpetas, la cual en la con\ufb01guraci\u00f3n inicial ya hemos visto. La descripci\u00f3n de las carpetas m\u00e1s importantes de Tomcat son las siguientes: bin: Archivos ejecutables, como por ejemplo los script para ejecutar el server o detenerlo . common: Clases comunes, son compartidas por el motor Tomcat (Catalina) o por las aplicaciones web. logs: Muestra los logs del servidor . webapps: Archivo que contiene las aplicaciones web (los artefactos). Instalar aplicaciones en Tomcat En el ejercicio anterior de prueba de funcionamiento de Tomcat, al momento de crear el html y encender el servidor mediante Eclipse, se vio la siguiente pantalla: La imagen muestra el \u00e1rea en donde Tomcat guarda las aplicaciones que va a levantar . Es el s\u00edmil de la carpeta webApps de la ubicaci\u00f3n de Tomcat , pero en este caso Eclipse se encarga de alojar la carpeta del proyecto en la ubicaci\u00f3n correcta . Al momento de subir el sitio mediante Eclipse, el contenedor est\u00e1 con\ufb01gurado para levantar el proyecto y generar los recursos necesarios para publicar el sistema y as\u00ed puede ser accedido mediante http. Cambiar puerto de Tomcat Hay ocasiones, en que el puerto por defecto de Tomcat no es posible utilizarlo( 8080 ), o simplemente est\u00e1 ocupado por otras aplicaciones. La soluci\u00f3n es cerrar esas aplicaciones para liberar el puerto, pero existe otra alternativa que consta de cambiar el puerto por defecto del contenedor. Macintosh HD\u2069 \u25b8 \u2068Aplicaciones\u2069 \u25b8 \u2068contenedor\u2069 \u25b8 \u2068apache-tomcat-9.0.31\u2069 \u25b8 \u2068conf\u2069 Para generar el cambio, debemos dirigirnos dentro de la carpeta de instalaci\u00f3n de Tomcat en la carpeta: /conf . En la carpeta, debemos ubicar el archivo server.xml el cual tiene las con\ufb01guraciones globales del servidor Tomcat. Ver\u00e1s que es un archivo con bastantes l\u00edneas de c\u00f3digos, en donde lo importante para el cambio de puerto es la l\u00ednea: ... <Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /> ... Simplemente tenemos que cambiar el puerto por defecto a alg\u00fan otro, guardar y reiniciar Tomcat, para utilizar el puerto con\ufb01gurado. Protocolo http Competencias Utilizar protocolos http Entender el concepto de arquitectura web Entender request y response http Introducci\u00f3n Cuando un servidor web genera un request hacia un cliente, por lo general env\u00eda alg\u00fan tipo de contenido para que el navegador lo interprete y lo pueda mostrar al usuario. En la mayor\u00eda de los casos el servidor env\u00eda un set de instrucciones en formato de c\u00f3digo HTML (Hyper Text Markup Languaje). El HTML le indica al cliente c\u00f3mo debe visualizarse el recurso web que fue solicitado. Veremos la base para entender c\u00f3mo funciona el protocolo de transferencia de hiper texto . El protocolo http Sus siglas signi\ufb01can Hyper Text Transfer Protocol , o mejor dicho en espa\u00f1ol Protocolo de transferencia de hipertexto . Toda la interacci\u00f3n entre cliente y servidor es mediante este protocolo de comunicaci\u00f3n . El cliente env\u00eda un http-request y el servidor responde con un http-request . HTTP es un protocolo perteneciente a la capa de aplicaci\u00f3n y corre sobre otro protocolo llamado TCP. Es un protocolo ampliable, lo que signi\ufb01ca que en su evoluci\u00f3n ha sido capaz de transmitir no solo p\u00e1ginas web mediante html, si no que tambi\u00e9n es capaz de transmitir im\u00e1genes, audio, video, etc. El modelo request/response en HTTP El protocolo http, y todos los protocolos que est\u00e1n basados en \u00e9l, est\u00e1n construidos bajo el mismo modelo de comunicaci\u00f3n. Este modelo de comunicaci\u00f3n trabaja de la siguiente manera: Un cliente, t\u00edpicamente un navegador web, env\u00eda un request para que el servidor le devuelva cierto recurso. Cuando el server recibe el request, lo analiza, lo gestiona para luego enviar de vuelta un objeto response. Mensajes http-Request Veamos un ejemplo de request, en este caso inspeccionamos la p\u00e1gina de Desaf\u00edo Latam , para veri\ufb01car c\u00f3mo se env\u00eda la petici\u00f3n mediante http. En este ejemplo hacemos seguimiento a un archivo .css. Para abrir la consola del desarrollador, debes pinchar con bot\u00f3n derecho sobre la p\u00e1gina web y buscar la opci\u00f3n Inspeccionar. Al momento de presionar la opci\u00f3n, se abrir\u00e1 un sector en la parte inferior de la pantalla, con una serie de herramientas \u00fatiles para los desarrolladores: En el sector izquierdo, se puede apreciar el c\u00f3digo html que el navegador interpret\u00f3. Sirve mucho para veri\ufb01car las posiciones de tus elementos e inspeccionar errores de c\u00f3digo. Para poder ver los contenidos de los request y response de la p\u00e1gina web, debes pinchar la pesta\u00f1a Network y en su pantalla principal, al lado izquierdo en la columna name, seleccionar el recurso que se desea comprobar Al seleccionarlo, se ver\u00e1 toda la informaci\u00f3n del request en el lado derecho de la pantalla. Con esos pasos es posible investigar la mayor\u00eda de elementos que hacen que la p\u00e1gina web se despliegue. Vemos que la secci\u00f3n general, contiene una direcci\u00f3n URL, la cual est\u00e1 formada por: El protocolo La direcci\u00f3n del servidor La ubicaci\u00f3n del archivo css solicitado. Miremos la imagen de nuevo, vemos un sector que tiene el t\u00edtulo de REQUEST METHOD y su valor es GET . El valor get es un verbo http, y aparte del anterior existen varios m\u00e1s. Un verbo se utiliza para indicar de qu\u00e9 forma el request pide el recurso (m\u00e1s adelante veremos los verbos). Podemos ver tambi\u00e9n la direcci\u00f3n remota del servidor y la url de destino. Mensaje http-response Luego de generar un request a un servidor remoto, este nos devuelve nuestro recurso. La siguiente imagen muestra como es la respuesta: Lo importante de aqu\u00ed, es que el request internamente nos entrega bastante informaci\u00f3n sobre el recurso como: M\u00e9todo de respuesta, en este caso GET Content Type, en este caso un archivo .css La fecha. C\u00f3digos de error http Los request y los response vienen con un c\u00f3digo de respuesta, el cual es generado por el servidor para indicar el resultado de los mensajes. HTTP, de\ufb01ne varios c\u00f3digos de error, pero los m\u00e1s conocidos son: C\u00f3digo de respuesta HTTP Ejemplo de c\u00f3digo de error IBM\u00ae Ejemplo de descripci\u00f3n 200 OK Ninguno Se ha manejado correctamente una solicitud v\u00e1lida y, opcionalmente, se ha proporcionado una respuesta al usuario. 202 Accepted Ninguno Se ha manejado correctamente una solicitud v\u00e1lida pero no garantiza que la acci\u00f3n solicitada se haya completado. 400 Bad Request BFGWI0001 El URI no es v\u00e1lido porque le falta un tipo de recurso. 403 Forbidden BFGWI0056 No se ha de\ufb01nido ning\u00fan identi\ufb01cador de usuario. 404 Not Found BFGWI0015 No se puede encontrar el recurso solicitado. 405 Method Not Allowed BFGWI0016 El recurso solicitado no da soporte al verbo HTTP que se ha utilizado en la solicitud.Por ejemplo, se ha utilizado GET con un recurso que s\u00f3lo permite POST o DELETE. 410 Resource Gone BFGWI0031 El recurso solicitado ya no est\u00e1 disponible. Por ejemplo, el archivo solicitado ha sido suprimido del espacio de archivos. 413 Request Entity Too Large BFGWI0026 La solicitud contiene un archivo que es demasiado grande para ser manejado por el servidor. 415 Unsupported Media Type BFGWI0017 Se ha recibido una solicitud con un tipo de medio, especi\ufb01cado por la cabecera HTTP Content-type, que no est\u00e1 soportado. 500 Internal Server Error BFGWI0018 Se ha encontrado un error interno al gestionar la solicitud. Se ha producido un archivo FFDC o ABEND. (Archivos que genera IBM para manejar los errores). 502 Bad Gateway BFGWI0019 La solicitud no se puede completar porque se ha producido un error. 503 Service Unavailable BFGWI0020 El destino no est\u00e1 disponible temporalmente. 504 Gateway Timeout BFGWI0021 Un intento de completar la solicitud ha sobrepasado el tiempo de espera debido a los l\u00edmites de tiempo. Todos estos c\u00f3digos de error son generados de forma autom\u00e1tica por el servidor, y nos permite como desarrolladores saber cual es el tipo de problema que est\u00e1 afectando el correcto funcionamiento de nuestros sistemas . Por ejemplo, pensemos que nuestro sitio web tiene un banner con la imagen de nuestra empresa y necesitamos que se despliegue, pero por alg\u00fan motivo ajeno a nosotros, tal imagen se borr\u00f3 del servidor. El servidor detectar\u00e1 que el recurso que estamos pidiendo no existe y autom\u00e1ticamente enviar\u00e1 un error 404. Nosotros recibimos el c\u00f3digo de error y podemos avisar al usuario mediante alg\u00fan mensaje o alguna otra acci\u00f3n. La URL Su sigla signi\ufb01ca Uniform Resource Locators , y se encarga de identi\ufb01car las direcciones en donde se alojan los recursos web. Veamos su estructura: https://www.desafiolatam.com:8927/java/inicio Https: Indica al navegador el protocolo que utiliza en el requerimiento. En este ejemplo es https://www.desafiolatam.cl: direccion_del_servidor . Es la ubicaci\u00f3n f\u00edsica de la m\u00e1quina en la cual esta alojado el sitio. Puerto: puerto de escucha del servidor. Path: Es la ubicaci\u00f3n f\u00edsica de los documentos que estamos solicitando, en el servidor. Introducci\u00f3n a los servlets Competencias Conocer la teor\u00eda detr\u00e1s de los servlets. Conocer el ciclo de Vida de los servlets. Aplicar ejemplo de uso del ciclo de vida. Introducci\u00f3n Los servlets, son componentes java que tienen la capacidad de generar contenido web din\u00e1mico mediante request y response http. Esta tecnolog\u00eda extiende las capacidades de un sistema web que reside dentro de un contenedor web , el cual le otorga una serie de servicios de plataforma. Utilizando servlets, puedes perfectamente generar una p\u00e1gina web completa solamente con c\u00f3digo java y adem\u00e1s utilizar todo el poder\u00edo de la orientaci\u00f3n a objetos y la vasta biblioteca de clases que ofrece el jdk. Esto se traduce en que puedes armar un sistema web din\u00e1mico, con manejo de variables y funciones java como si fuera una aplicaci\u00f3n de consola, pero con una salida web mediante http y p\u00e1gina html . Los servlets Como mencionamos hace poco, un servlet no es m\u00e1s que una clase java que trabaja dentro de un contenedor de servlets como Apache Tomcat, el cual es el encargado de extender la funcionalidad de la clase y darle m\u00e1s \"poder\" por decirlo de una forma. El servlet fuera del contenedor Tomcat pierde todo su poder y se convierte en un archivo de texto m\u00e1s , con extensi\u00f3n java imposible de ejecutar, ya que esta clase no cuenta con un m\u00e9todo \"Main\" que ejecute la rutina. Para gra\ufb01car el \ufb02ujo de trabajo de una petici\u00f3n web, pensemos en una p\u00e1gina web que solicita alg\u00fan tipo de recurso (puede ser desde un formulario web hasta una galer\u00eda de fotos, como tambi\u00e9n el c\u00e1lculo del iva de alg\u00fan valor) a un servlet. El servlet recibe la petici\u00f3n mediante el protocolo HTTP y hace su trabajo (puede ser crear los campos del formulario web, ir a buscar una imagen de la galer\u00eda de fotos o hacer el c\u00e1lculo del iva, etc...) para luego mediante el response (la respuesta) devuelve el recurso al navegador. La imagen, muestra el \ufb02ujo normal de petici\u00f3n entre clientes (navegador web) y servidor (contenedor de servlets, aqu\u00ed est\u00e1n los servlets). Esta es, la arquitectura t\u00edpica de un sistema web, la cual es conocida como cliente-servidor . Ciclo de vida de un Servlet El ciclo de vida completo de un servlet es administrado por el contenedor de servlet y, antes de empezar a programarlos, hay que entender c\u00f3mo funciona la creaci\u00f3n y el funcionamiento de estos elementos de software. El ciclo de vida se divide en 4 pasos bien de\ufb01nidos: Carga del servlet. Inicializaci\u00f3n del servlet. Captura del request. Destrucci\u00f3n el request. Carga del servlet La primera etapa del ciclo de vida de un servlet parte con su inicializaci\u00f3n gracias al servidor Tomcat. El servidor ejecuta dos pasos en esta etapa: Loading : Carga de la clase servlet Instantiation : Creaci\u00f3n de una instancia del servlet. Para crear una nueva instancia del servlet, el contenedor utiliza un constructor sin par\u00e1metros. Inicializaci\u00f3n de Servlets Despu\u00e9s de que el servlet fue instanciado correctamente, el contenedor se encarga inicializarlo. \u00c9sto lo realiza invocando al m\u00e9todo Servlet.init() , que acepta la referencia del objeto ServletCon\ufb01g como par\u00e1metro. El m\u00e9todo Servlet.init() es invocado por el servidor solamente una vez, inmediatamente despu\u00e9s de que el objeto Servlet.init(ServletConfig) sea instanciado correctamente. En caso de que el servlet falle en su inicializaci\u00f3n, el contenedor lanza las excepciones: ServletException y UnavailableException . Captura del Request Despu\u00e9s de la inicializaci\u00f3n, la instancia del servlet est\u00e1 lista para atender los request del cliente. El contenedor de servlet realiza las siguientes operaciones cuando la instancia del servlet est\u00e1 lista: Crea los objetos ServletRequest y ServletResponse. Despu\u00e9s de crear los objetos ServletRequest y ServletResponse, se invoca al m\u00e9todo Servlet.service (ServletRequest, ServletResponse) al pasar los objetos de solicitud y respuesta. Mientras el m\u00e9todo service() procesa el request puede lanzar las excepciones ServletException, UnavailableException, e IOException. Destruir el Servlets Cuando el contenedor decide destruir el servlet, ejecuta las siguientes acciones: Permite que todos los subprocesos que se ejecutan actualmente en el m\u00e9todo de servicio de la instancia de Servlet completen sus trabajos y sean liberados. Despu\u00e9s de que los procesos en ejecuci\u00f3n hayan completado sus trabajos, el contenedor Servlet llama al m\u00e9todo destroy() en la instancia de Servlet. Una vez ejecutado el m\u00e9todo destroy() , El Servlet container libera todas las referencias de esta instancia de Servlet para que sea elegible para el garbage collector. Se grafica un ejemplo de un servlet simple en la siguiente imagen. Creaci\u00f3n del primer servlet Competencias Entender c\u00f3mo se compone un servlet. Compilaci\u00f3n de un servlet. Probar servlets en el contenedor. Conocer los m\u00e9todos de los servlets. Introducci\u00f3n En una arquitectura web, la comunicaci\u00f3n entre cliente y servidor es crucial para un funcionamiento colaborativo, y dentro de la tecnolog\u00eda JEE, un servlet, es uno de los principales actores. Ya estudiamos qu\u00e9 es un servlet y cual es su ciclo de vida, por lo que ahora es tiempo de empezar a implementarlos para descubrir poco a poco cuales son sus funciones y que nos permiten hacer. Composici\u00f3n de un servlets. Los servlets se construyen basados en la herencia de su clase padre Http Servlets, clase p\u00fablica y abstracta que permite que una clase herede los m\u00e9todos y atributos que hacen que se convierta en un servlets. La clase que herede de esta clase abstracta, debe sobreescribir al menos: + M\u00e9todo doGet + M\u00e9todo doPost + M\u00e9todo doDelete Esta regla es de oro y, teniendo esto en mente, comenzaremos a generar el primer servlet. Creaci\u00f3n de un servlet. Creamos un nuevo proyecto de tipo Dinamic Web Proyect y nombramos al mismo como PrimerServlet. Avanzamos en el wizard con next y \ufb01nish. Por el momento dejamos las opciones de web.xml por defecto. Al \ufb01nal Eclipse nos genera una estructura de Proyecto, la cual usaremos como base para nuestro trabajo. Por el momento la carpeta importante para nosotros es la Java Resources , que contendr\u00e1 el c\u00f3digo fuente de nuestro programa. Se compone de: La carpeta src , que aloja las clases java y la estructura de paquetes de la aplicaci\u00f3n. La carpeta libraries , que mantiene las librer\u00edas utilitarias. La carpeta build , que mantiene las clases autogeneradas. Luego de generar el Proyecto, vamos a crear nuestra primera clase. Para hacer esta labor, tenemos que seleccionar el nombre del proyecto con bot\u00f3n derecho, y presionar new, class. Una vez creado el proyecto, podemos ver que en: /PrimerServlet/src/cl/lherrera/web/servlets/GeneradorIndex.java package cl.lherrera.web.servlets; public class GeneradorIndex { } Esto por si solo no hace nada, hay que segir trabajandolo. @WebServlet(\"/inicio\"), Es una anotaci\u00f3n, que le indica al contenedor de servlets que esta clase es un servlet, que debe ser accedido mediante URL y su path contenedor es /inicio. Recordemos que un servlet es un componente web que ser\u00e1 accedido por internet, por lo que para ubicar el elemento, debemos llamarlo mediante la direcci\u00f3n url del recurso. El primer m\u00e9todo protected es heredado desde la clase HttpServlet y su nombre es doGet() . Por el momento sabemos que este m\u00e9todo permite devolver una respuesta al navegador del cliente mediante el m\u00e9todo get. El resto del c\u00f3digo es java puro, simplemente estamos generando texto y se lo pasamos a un m\u00e9todo. Algo a destacar es la generaci\u00f3n de c\u00f3digo html en el mismo archivo java. Puedes ver que al imprimir c\u00f3digo estamos generando etiquetas html, las cuales el navegador puede interpretar directamente. El servlet nos queda entonces de la siguiente manera: package cl.lherrera.web.servlets; import java.io.IOException; import java.io.PrintWriter; import java.rmi.ServerException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; @WebServlet(\"/inicio\") public class GeneradorIndex extends HttpServlet { protected void doGet( HttpServletRequest request, HttpServletResponse response) throws IOException, ServerException { // variable de sessi\u00f3n HttpSession session = request.getSession(); // creador de contenido web PrintWriter salida = response.getWriter(); // Texto a imprimir, un alert de Javascript (web) StringBuilder textoWeb = new StringBuilder(\"<script type=\\\"text/javascript\\\">\"); textoWeb.append(\"alert('Hola desde GeneradorIndex !!');\"); textoWeb.append(\"</script>\"); // imprime en el documento HTML salida.println(textoWeb.toString()); return; } } No hay que olvidar poner un index.html , para que cargue por defecto al iniciar el servidor. Manejo de informaci\u00f3n entre servlets Competencias: Entender el funcionamiento de m\u00e9todos getParams. Enviar par\u00e1metros desde el cliente. Aplicar el env\u00edo de informaci\u00f3n entre servlets. Introducci\u00f3n Los servlet, no solamente se encarga de devolver recursos a los clientes que lo solicitan, tambi\u00e9n puede comunicarse con otras clases servlets para compartir informaci\u00f3n y articular el \ufb02ujo correcto de un sistema web. Esta capacidad es una gran raz\u00f3n del por que esta tecnolog\u00eda es tan demandada y veremos la forma en la cual estas clases pueden comunicarse entre s\u00ed compartiendo sus variables y dando funcionalidad al sistema. Creaci\u00f3n de servlet de generaci\u00f3n respuesta Los servlets tienen la capacidad de recibir par\u00e1metros desde los clientes, para luego procesarlos y generar salidas. El objeto request, es el encargado de manejar tales par\u00e1metros y gracias a \u00e9l, podemos acceder a los datos enviados. Para entender el funcionamiento de esta caracter\u00edstica vamos a implementar una nueva funcionalidad en un ejemplo. En el ejemplo anterior, le sumamos ahora la captura de par\u00e1metros enviados desde el cliente: package cl.lherrera.web.servlets; import java.io.IOException; import java.io.PrintWriter; import java.rmi.ServerException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; @WebServlet(\"/inicio\") public class GeneradorIndex extends HttpServlet { protected void doGet( HttpServletRequest request, HttpServletResponse response) throws IOException, ServerException { // captura de par\u00e1metros String nombre = request.getParameter(\"nombre\"); String apellido = request.getParameter(\"apellido\"); // variable de sessi\u00f3n HttpSession session = request.getSession(); // creador de contenido web PrintWriter salida = response.getWriter(); // Texto a imprimir, un alert de Javascript (web) StringBuilder textoWeb = new StringBuilder(\"<script type=\\\"text/javascript\\\">\"); textoWeb.append(\"alert('Hola \"+ nombre + \" \" + apellido + \" desde GeneradorIndex !!');\"); textoWeb.append(\"</script>\"); salida.println(textoWeb.toString()); return; } } URL: http://localhost:8080/PrimerServlet/inicio?nombre=Luis&apellido=Herrera Aplicar el env\u00edo de informaci\u00f3n entre Servlets Si bien el \ufb02ujo normal entre un cliente servidor es desde navegador a servidor, hay ocasiones en que se requiere que en la capa de negocio un servlet pueda comunicarse con otro servlet. Para lograr este objetivo, java nos provee de los m\u00e9todos: /** * m\u00e9todo otorgado por HttpRequest, que obtiene el contexto * del servlet que queremos utilizar. */ getRequestDispatcher() /** * luego de obtener el contexto, le enviamos la direcci\u00f3n del servlet. */ getServletContext() Si en nuestro proyecto agregamos otro servlet. Este llamar\u00e1 a nuestro primer servlet, y le pasar\u00e1 el request y response, que le lleg\u00f3. package cl.lherrera.web.servlets; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; @WebServlet(\"/inicio\") public class GeneradorIndex extends HttpServlet { /** * */ private static final long serialVersionUID = 1L; protected void doGet( HttpServletRequest request, HttpServletResponse response) throws IOException { // captura de par\u00e1metros String nombre = request.getParameter(\"nombre\"); String apellido = request.getParameter(\"apellido\"); // variable de sessi\u00f3n HttpSession session = request.getSession(); // creador de contenido web PrintWriter salida = response.getWriter(); // Texto a imprimir, un alert de Javascript (web) StringBuilder textoWeb = new StringBuilder(\"<script type=\\\"text/javascript\\\">\"); textoWeb.append(\"alert('Hola \"+ nombre + \" \" + apellido + \" desde GeneradorIndex !!');\"); textoWeb.append(\"</script>\"); salida.println(textoWeb.toString()); return; } } http://localhost:8080/PrimerServlet/llamainicio?nombre=Luis&apellido=Herrera Introducci\u00f3n a los Formularios y JTSL con JSP Competencias: Entender la funci\u00f3n de un formulario. Introducci\u00f3n a la tecnolog\u00eda JSP y JSTL. Instalaci\u00f3n de librer\u00edas JSTL. Aplicar envio de variables entre formularios. Introducci\u00f3n Los formularios con JSP est\u00e1n hechos con html puro, lo que signi\ufb01ca que no debemos saber nada extra para generar formularios. Lo que s\u00ed hay que tener en cuenta, es el mecanismo para enviar informaci\u00f3n y recibirla entre distintos archivos jsp. Utilizando JSTL es posible f\u00e1cilmente el env\u00edo de valores de formularios mediante m\u00e9todos post o get. Haremos unos ejemplos que gra\ufb01can este mecanismo. Haremos un acercamiento a la tecnolog\u00eda JSTL y a los JSP, pero no ser\u00e1 muy extenso, ya que esta tecnolog\u00eda se tratar\u00e1 en detalle en unidades posteriores. El objetivo real es entender c\u00f3mo es el proceso de envio de informacion entre formularios y servlets. Qu\u00e9 es un formulario web Pensemos un momento en una p\u00e1gina web, con estilos y estructuras que permiten al usuario enterarse de los productos o servicios que una empresa puede ofrecer. Tal p\u00e1gina es solo descriptiva ya que solamente se encarga de desplegar informaci\u00f3n y mostrarla de manera ordenada y atractiva. Pero hay un tema pendiente el cual es la interacci\u00f3n con el usuario . La persona que usa la web no tiene ninguna forma de alimentar con datos al sitio web, y por consiguiente no hay forma de procesar datos ni tampoco de generar conocimientos. Aqu\u00ed entran en juego los formularios web, que son el primer puente entre el usuario y las bases de datos, o la l\u00f3gica real de la empresa . Estos elementos web poseen componentes, que capturan los datos del usuario mediante cajas de texto, listas desplegables, combos de opciones y una serie de componentes html, y gracias a ellos una simple p\u00e1gina web est\u00e1tica se puede convertir en un real sistema web (acompa\u00f1ado de alg\u00fan lenguaje de programaci\u00f3n por el lado del servidor y una base de datos obviamente). Introducci\u00f3n a los JSP y JSTL . JSP Java Server Page , m\u00e1s conocido simplemente como jsp, es una tecnolog\u00eda del stack Java JEE que se encarga de proveer herramientas para que los desarrolladores puedan construir p\u00e1ginas web generadas din\u00e1micamente, basadas en el lenguaje de marcado HTML, XML u otro tipo de documentos. Fue lanzado en el a\u00f1o 1999 por Sun Microsystem. Tiene muchas similitudes con otras tecnolog\u00edas como lo son PHP o ASP , pero implementando el lenguaje de programaci\u00f3n Java. Para poder utilizar esta tecnolog\u00eda JSP, es necesario contar con un servidor web compatible con un contenedor de servlets como apache, el cual ya fue utilizado en unidades anteriores. Si analizamos la arquitectura, JSP est\u00e1 basada en el funcionamiento de los servlets, ya que al ser ejecutados, las p\u00e1ginas JSP se convierten internamente en servlets en tiempo de ejecuci\u00f3n , por lo tanto se podr\u00eda decir que una p\u00e1gina JSP es en realidad un servlet . Una p\u00e1gina JSP se puede utilizar utilizando dos mec\u00e1nicas: Como componente de vista de un dise\u00f1o del lado del servidor , trabajando codo a codo con clases Java Bean como el modelo y con servlets como controlador. Posteriormente profundizaremos en la arquitectura cliente servidor. Como un componente independiente , con JSP, podemos incrustar c\u00f3digo java y ciertas acciones prede\ufb01nidas como inicializaci\u00f3n de variables e importaciones en una p\u00e1gina web con HTML (mezclamos contenido din\u00e1mico y contenido est\u00e1tico) . La p\u00e1gina pasa por una etapa de compilaci\u00f3n y ejecuci\u00f3n dentro del servidor para poder entregar un documento . Las p\u00e1ginas compiladas, al igual que las bibliotecas java contienen el c\u00f3digo en formato de ByteCode en vez de c\u00f3digo de m\u00e1quina. Al igual que otro programa en java, el archivo debe ejecutarse dentro de una m\u00e1quina virtual Java (JVM) que interact\u00faa con el sistema operativo host del servidor para proporcionar un entorno neutral para la plataforma. Los JSP se utilizan para generar documentos HTML y XML, pero a trav\u00e9s del uso de OutPutStream, tambi\u00e9n son capaces de entregar otros tipos de datos. El contenedor web, crea objetos JSP impl\u00edcitos como request, response, sesiones, aplicaciones, con\ufb01guraciones, p\u00e1ginas html, salidas y excepciones. El motor de las java Servlets Page crea estos objetos durante la fase de traducci\u00f3n (al igual que los servlets, las p\u00e1ginas JSP tienen el mismo ciclo de vida). JSTL (JavaServer Pages Standard Tag Library) La librer\u00eda JSTL, es un componente dentro de la especificaci\u00f3n del Java 2 Enterprise Edition (J2EE), JSTL no es m\u00e1s que un conjunto de librer\u00edas de etiquetas simples y est\u00e1ndares que encapsulan la funcionalidad principal que es usada com\u00fanmente para escribir p\u00e1ginas JSP. Las etiquetas JSTL est\u00e1n organizadas en 4 librer\u00edas: core : Comprende las funciones script b\u00e1sicas como loops, condicionales, y entrada/salida. xml : Comprende el procesamiento de xml fmt : Comprende la internacionalizaci\u00f3n y formato de valores como de moneda y fechas. sql : Comprende el acceso a base de datos. Utilizando estos componentes, podemos entregar mucha m\u00e1s potencia a nuestros documentos web, por ejemplo, podemos usar un loop de core , para desplegar una grilla, iterando con los resultados. Caracter\u00edsticas m\u00e1s signi\ufb01cativas de JSTL JSTL tambi\u00e9n es JSP, siendo un conjunto complementario de este. Utiliza 4 librer\u00edas est\u00e1ndar: SQL, XML, CORE, INTERNALIZACI\u00d3N JSTL de\ufb01ne un nuevo lenguaje de expresiones llamado EL. Al usar una etiqueta JSTL, lo que hacemos en a\u00f1adir una acci\u00f3n. Una etiqueta JSTL est\u00e1 delimitada por ${ } . Agregar JSTL a un proyecto (manualmente) JSTL, no est\u00e1 en el api oficial, por lo tanto hay que descargarlo, para la descarga utilizamos la siguiente URL: jstl-standard , jstl.jar , jstl-impl.jar . Luego de eso, debemos dejar los archivos en una carpeta en el pc, en mi caso la he dejado en la carpeta aplicaciones junto a Apache Tomcat , pero el destino no importa mientras no eliminemos los jars . Con los archivos en una carpeta, accedemos al proyecto y en las propiedades ir a, Java Build Path, agregar las librer\u00edas externas, aplicar y cerrar. Una vez relizado esto, debemos agregar manualmente las librer\u00edas a /PrimerServlet/WebContent/WEB-INF/lib/ , las tres, simplemente copiando y pegando desde donde las tenemos. Finalmente creamos un archivo JSP , llamado PrimerUsoJstl.jsp , lo creamos en WebContent , con el siguiente contenido: /PrimerServlet/WebContent/PrimerUsoJstl.jsp <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%> <!DOCTYPE html> <html> <head> <meta charset=\"UTF-8\"> <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\"%> <%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\"%> <%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\"%> <%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\"%> <title>Usando JSTL</title> </head> <body> <p>Cadena de caracteres: <strong> <!-- ac\u00e1 se hace uso del core, es como un System.out.println() --> <c:out value=\"1+2+3\" /> </strong> </p> </body> </html> Ejecutamos la aplicaci\u00f3n con el servidor obteniendo el siguiente resultado: Tags JSTL Para referenciar la librer\u00eda JSTL Core en una p\u00e1gina JSP, debemos declarar la cabecera del documento como a continuaci\u00f3n: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> Lo m\u00e1s signi\ufb01cativo es el prefix=\"c\" , que especi\ufb01ca el tipo de etiqueta y el contexto (conjunto de variables que se poseen, el contexto de la sesi\u00f3n, solamente posee las variables asociadas a la sesi\u00f3n) que se necesita utilizar mediante JSTL. JSTL incluye una gran variedad de tags que engloban distintas \u00e1reas funcionales. Para segmentar estas \u00e1reas, se utilizan namespaces. JSTL expone m\u00faltiples tags en estas url (no son links, son la ubicaci\u00f3n del recurso uri ): Core: http://java.sun.com/jsp/jstl/core XML: http://java.sun.com/jsp/jstl/xml Internationalization: http://java.sun.com/jsp/jstl/fmt SQL: http://java.sun.com/jsp/jstl/sql Functions: http://java.sun.com/jsp/jstl/functions Esta tabla nos expone las opciones disponibles de JSTL: Ejemplos finales Ejemplo usando JSTL (Uso de ${} ) Creamos un nuevo .jsp : /PrimerServlet/WebContent/ejemplo001.jsp , esto no solamente imprimir\u00e1 una cadena, si no que adem\u00e1s realizar\u00e1 operaciones aritm\u00e9ticas como si lo estubieramos realizando desde Java. <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%> <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %> <%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\" %> <%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %> <%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\" %> <!DOCTYPE html> <html> <head> <meta charset=\"UTF-8\"> <title>Usando JSTL</title> <style> p {} #texto { margin: 0 auto; width: 300px; height: 100px; border: solid 1px black; padding-left: 30px; } #cabecera { margin: 0 auto; width: 300px; border: solid 1px black; padding-left: 30px; background-color: green; color: white; } </style> </head> <body> <div id=\"cabecera\"> <h3>Ejemplos con JSTL salida estandar </h3> </div> <div id=\"texto\"> <p>Cadena de caracteres: <c:out value=\"1+2+3\" /> </p> <p>Suma de caracteres: <c:out value=\"${1+2+3}\" /> </p> </div> </body> </html> Ejemplo: Env\u00edo de valores entre jsp En este ejercicio crearemos un simple formulario, con la entrada de dos valores nombre y apellido, que luego de ser enviados ser\u00e1n recibidos por un jsp con las etiquetas c: out . Es decir que ingresaremos valores en un formulario y estos valores ser\u00e1n luego mostrados. El env\u00edo en este caso, puede ser realizado por get o por post. El verdadero poder de core radica en poder tener acceso a los par\u00e1metros de manera r\u00e1pida y sencilla. Creamos dos archivos `jsp`` /PrimerServlet/WebContent/ejemplo002.jsp /PrimerServlet/WebContent/muestraRespuesta.jsp ejemplo002.jsp <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%> <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %> <%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\" %> <%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %> <%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\" %> <!DOCTYPE html> <html> <head> <meta charset=\"UTF-8\"> <title>Usando JSTL</title> <style> p {} #texto { margin: 0 auto; width: 300px; height: 100px; border: solid 1px black; padding-left: 30px; } #cabecera { margin: 0 auto; width: 300px; border: solid 1px black; padding-left: 30px; background-color: green; color: white; } </style> </head> <body> <div id=\"cabecera\"> <h3>FORMULARIO DE ENV\u00cdO</h3> </div> <div id=\"texto\"> <form action=\"muestraRespuesta.jsp\" method=\"get\"> <label for=\"nombre\">Nombre</label> <input type=\"text\" placeholder=\"Ingrese nombre\" id=\"nombre\" name=\"nombre\"><br /> <label for=\"apellido\">Apellido</label> <input type=\"text\" placeholder=\"Ingrese apellido\" id=\"apellido\" name=\"apellido\"> <input type=\"submit\" value=\"Enviar\"> </form> </div> </body> </html> muestraRespuesta.jsp <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%> <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %> <%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\" %> <%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %> <%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\" %> <!DOCTYPE html> <html> <head> <meta charset=\"UTF-8\"> <title>Usando JSTL</title> <style> p {} #texto { margin: 0 auto; width: 300px; height: 100px; border: solid 1px black; padding-left: 30px; } #cabecera { margin: 0 auto; width: 300px; border: solid 1px black; padding-left: 30px; background-color: green; color: white; } </style> </head> <body> <div id=\"cabecera\"> <h3>Ejemplo JSTL salida estandar</h3> </div> <div id=\"texto\"> <p>Nombre: <c:out value=\"${ param.nombre }\"/></p> <p>Apellido: <c:out value=\"${ param.apellido }\"/></p> </div> </body> </html> Queda de ejercicio hacerlo con bootstrap. Como se ha visto en las pr\u00e1cticas, con el uso de jstl y jsp es muy simple generar una comunicaci\u00f3n \ufb02uida entre elementos de una aplicaci\u00f3n web. Por el momento solo se reviso lo m\u00e1s b\u00e1sico de los tags JSTL , ya que adem\u00e1s de permitir el env\u00edo de datos entre formularios jsp, tambi\u00e9n cuentan con iteraciones, decisiones, tags de manejos de informaci\u00f3n y m\u00e1s, pero para comenzar a entender las arquitecturas y la comunicaci\u00f3n entre componentes es un muy buen comienzo.","title":"Lectura 1"},{"location":"modulos/mod_4/mod4_uni001/#unidad-1-introduccion-a-java-servlets-y-jsp","text":"","title":"Unidad 1: Introducci\u00f3n a Java Servlets y JSP"},{"location":"modulos/mod_4/mod4_uni001/#introduccion-a-java-servlets-y-jsp-parte-i","text":"","title":"Introducci\u00f3n a Java Servlets y JSP - Parte I"},{"location":"modulos/mod_4/mod4_uni001/#competencias","text":"Conocer herramientas involucradas. Instalar el kit de desarrollo de java (JDK) en mac. Instalar el kit de desarrollo de java (JDK) en Windows. Conocer e instalar el entorno de desarrollo Eclipse. Conocer e instalar el contenedor web Apache. Comprobar el correcto funcionamiento del servidor Tomcat .","title":"Competencias"},{"location":"modulos/mod_4/mod4_uni001/#introduccion","text":"Para comenzar con las labores de desarrollo es necesario contar con un ambiente perfectamente instalado y con\ufb01gurado para poder trabajar de forma c\u00f3moda y productiva. El stack de tecnolog\u00edas que utilizaremos se pueden observar en la imagen 1.","title":"Introducci\u00f3n"},{"location":"modulos/mod_4/mod4_uni001/#jdk-instalacion","text":"La JDK ( Java Developed Kit ) es la biblioteca esencial de java. Nos proporciona la biblioteca de clases java, la Java Virtual Machine , el compilador, documentaci\u00f3n, entre otros. Para instalarlo en cualquier entorno ya sea mac, Windows o Linux, primero hay que descargarla desde la pagina web o\ufb01cial.","title":"JDK instalaci\u00f3n"},{"location":"modulos/mod_4/mod4_uni001/#que-paquete-java-necesito","text":"Desarrolladores de software: JDK (Java SE Development Kit) Para desarrolladores de Java. Incluye un JRE completo m\u00e1s herramientas para desarrollar, depurar y monitoreo de aplicaciones Java. Administradores que ejecutan aplicaciones en un servidor: Servidor JRE (Server Java Runtime Environment) Para desplegar aplicaciones Java en servidores. Incluye herramientas para el monitoreo de JVM y herramientas com\u00fanmente requeridas para aplicaciones de servidor, pero no incluye integraci\u00f3n de navegador (el complemento de Java), actualizaci\u00f3n autom\u00e1tica ni un instalador. Usuario \ufb01nal que ejecuta Java en un escritorio: JRE (Java Runtime Environment) . Cubre la mayor\u00eda de las necesidades de los usuarios \ufb01nales. Contiene todo lo necesario para ejecutar aplicaciones Java en su sistema.","title":"\u00bfQu\u00e9 paquete Java necesito?"},{"location":"modulos/mod_4/mod4_uni001/#instalacion-jdk-en-mac","text":"El primer paso es descargar el jdk desde el link adjunto. Nos mostrar\u00e1 una p\u00e1gina con las opciones de descarga: Seleccionamos la versi\u00f3n correspondiente a la de nuestro sistema operativo. En caso de utilizar mac obtendr\u00e1s el archivo jdk-8u201-macosx-x64.dgm . Para instalar solamente ejecuta el archivo .dmg y sigue las instrucciones siguiente siguiente para terminar con la instalaci\u00f3n. En mac no es necesario con\ufb01gurar variables de entorno. Para veri\ufb01car la versi\u00f3n del jdk que tenemos instalada, abre una consola e ingresa el comando java \u2013versi\u00f3n . \u279c java -version java version \"1.8.0_181\" Java(TM) SE Runtime Environment (build 1.8.0_181-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode) En caso de no tener el JDK, la consola lanzar\u00e1 un error indicando que no se encuentra el java developer kit .","title":"Instalaci\u00f3n JDK en MAC"},{"location":"modulos/mod_4/mod4_uni001/#instalacion-jdk-en-windows","text":"Plataformas: Windows 2008 Server Windows 7 Windows 8 Windows XP Windows Server 2012 Windows Vista Windows 10. Veri\ufb01car la instalaci\u00f3n actual en tu Windows. Abrir una ventana CMD utilizando el men\u00fa contextual. Ejecutar: java -version javac -version Si esto no funciona, se debe descargar el JDK indicado para el sistema operativo que se posee en el siguiente link","title":"Instalaci\u00f3n JDK en Windows"},{"location":"modulos/mod_4/mod4_uni001/#instalacion-de-ide-eclipse","text":"Para el correcto seguimiento de los ejercicios utilizaremos Eclipse, ide para java con muchas caracter\u00edsticas que lo hacen uno de los m\u00e1s usados. Es multiplataforma por estar escrito en java, y solo hay que descargarlo y dejarlo en una ubicaci\u00f3n en tu equipo. Perfectamente podr\u00edas utilizar otro ide como netbeans o intellij, pero correr\u00eda por tu cuenta su funcionamiento particular. Para descargar el ide, dirigirse a la p\u00e1gina de descargas de Eclipse . Esperar a que la descarga se complete. Terminar\u00e1s con un archivo comprimido, el cual,se debe ubicar en alguna carpeta de tu equipo a elecci\u00f3n. Se sugiere crear una carpeta independiente para el ide. Dentro de archivo de descarga ver\u00e1s un icono de Eclipse, el cual debes ejecutar con doble click. Con esa acci\u00f3n basta para ejecutar el ide. Para los equipos mac, el archivo descargado es de tipo .dmg y para Windows el archivo es de tipo .exe. Al ejecutar el instalador, se nos mostrar\u00e1 una pantalla en donde nos pide seleccionar la versi\u00f3n de Eclipse que deseamos instalar. En este caso debemos pinchar la opci\u00f3n de Eclipse IDE for java EE developers \ud83d\udc40. Esta versi\u00f3n es la indicada para programar con Java Enterprise Edition.","title":"Instalaci\u00f3n de ide Eclipse"},{"location":"modulos/mod_4/mod4_uni001/#instalacion-del-contenedor-apache","text":"En esta etapa debemos instalar el servidor que har\u00e1 que las aplicaciones puedan ejecutarse en entorno local . El contenedor de aplicaciones es el software que otorga los servicios necesarios a los artefactos que generamos en este curso, y en esta ocasi\u00f3n utilizaremos el contenedor de servlets Apache Tomcat . Debemos entonces descargar el contenedor desde la siguiente URL . En la ventana, en la secci\u00f3n de nombre Binary Distributions descargamos desde la secci\u00f3n Core la versi\u00f3n del comprimido de Tomcat. Descargar el archivo zip (pgp, sha512) y crear en una carpeta de nombre contenedor en nuestro equipo. Se recomienda dejar la carpeta en C:/ en Windows, o en Aplicaciones en mac. El archivo descargado es un archivo comprimido que debemos descomprimir en la carpeta reci\u00e9n creada. Tanto en Mac como en Windows, el contenido de la carpeta no var\u00eda , manteniendo la misma estructura de carpetas. En este ejemplo se muestra la ubicaci\u00f3n en un equipo Mac. Teniendo en nuestro poder el contenedor Tomcat, es tiempo de con\ufb01gurarlo. Cabe decir que existen dos formas de con\ufb01guraci\u00f3n en un entorno de desarrollo. Con\ufb01gurado directamente en Eclipse. Con\ufb01gurado de forma manual en el equipo. Con\ufb01guraremos el contenedor directamente en Eclipse , ya que nos evita tener que ejecutar con\ufb01guraciones extras que si tendr\u00edamos que hacer en una con\ufb01guraci\u00f3n est\u00e1ndar. Otra ventaja que Eclipse integra una vista de servidores la cual nos permite levantar, apagar, limpiar y dar mantenci\u00f3n al contenedor Tomcat. De forma manual todas estas acciones b\u00e1sicas deben hacerse mediante consola de comandos. En la secci\u00f3n de proyectos, ejecutamos command + n y escribimos server . Esto nos lleva a la secci\u00f3n de configuraci\u00f3n de servidores para eclipse. La versi\u00f3n descargada fue la 9.0.31 , es por eso que debemos ir a: Apache -> Tomcat v9.0 Server Luego, debemos indicar donde se encuentra nuestro Apache Tomcat , en mi caso est\u00e1 en aplicaciones, dentro de una carpeta llamada contenedor . /Applications/contenedor/apache-tomcat-9.0.31 . Se recomienda seleccionar el JDK versi\u00f3n 1.8, por defecto para evitar en el caso que tengamos otra instalaci\u00f3n que se ejecute nuestro server en un JDK que no queremos. Al \ufb01nalizar, Eclipse enlazara el servidor Tomcat a la vista de servidores de Eclipse. Para poder probar si es que tenemos el servidor bien configurado nos vamos a la perspectiva WEB , y en la pesta\u00f1a servers, presionamos play. Adicional a esto, podremos crear una prueba, para poder comprobar el correcto servicio de Apache Tomcat . Es por esto que vamos a crear un proyecto de web din\u00e1mica. Dejamos las configuraciones por defecto, aunque para este caso se escoge la opci\u00f3n de la configuraci\u00f3n por defecto de Apache Tomcat 9.0. En /proyectoPrueba/WebContent/ , creamos un index.html . Luego ejecutamos desde el servidor, no como aplicaci\u00f3n. Con esto deber\u00edamos tener nuestra web funcionando correctamente.","title":"Instalaci\u00f3n del contenedor Apache"},{"location":"modulos/mod_4/mod4_uni001/#contenedor-tomcat","text":"","title":"Contenedor Tomcat"},{"location":"modulos/mod_4/mod4_uni001/#competencias_1","text":"Conocer caracter\u00edsticas del contenedor Tomcat Desplegar aplicaciones en Tomcat Con\ufb01gurar puerto de funcionamiento","title":"Competencias"},{"location":"modulos/mod_4/mod4_uni001/#introduccion_1","text":"El software Apache Tomcat es una implementaci\u00f3n de c\u00f3digo abierto de: Java Servlet JavaServer Pages Java Expression Language Java WebSocket. Las especi\ufb01caciones de Java Servlet, JavaServer Pages, Java Expression Language y Java WebSocket se desarrollan bajo el Proceso de la Comunidad Java. Tomcat cumple la funci\u00f3n de contenedor de servlets y est\u00e1 desarrollado en java, lo que signi\ufb01ca que puede correr en distintas arquitecturas , ya sea windows, linux o mac, siempre y cuando exista una m\u00e1quina virtual instalada . Aparte de ser un contenedor de servlets, tambi\u00e9n es un servidor web , por lo cual es posible subir sitios web din\u00e1micos a su infraestructura.","title":"Introducci\u00f3n"},{"location":"modulos/mod_4/mod4_uni001/#estructura","text":"Para conocer el funcionamiento de Tomcat, es necesario conocer su estructura de carpetas, la cual en la con\ufb01guraci\u00f3n inicial ya hemos visto. La descripci\u00f3n de las carpetas m\u00e1s importantes de Tomcat son las siguientes: bin: Archivos ejecutables, como por ejemplo los script para ejecutar el server o detenerlo . common: Clases comunes, son compartidas por el motor Tomcat (Catalina) o por las aplicaciones web. logs: Muestra los logs del servidor . webapps: Archivo que contiene las aplicaciones web (los artefactos).","title":"Estructura"},{"location":"modulos/mod_4/mod4_uni001/#instalar-aplicaciones-en-tomcat","text":"En el ejercicio anterior de prueba de funcionamiento de Tomcat, al momento de crear el html y encender el servidor mediante Eclipse, se vio la siguiente pantalla: La imagen muestra el \u00e1rea en donde Tomcat guarda las aplicaciones que va a levantar . Es el s\u00edmil de la carpeta webApps de la ubicaci\u00f3n de Tomcat , pero en este caso Eclipse se encarga de alojar la carpeta del proyecto en la ubicaci\u00f3n correcta . Al momento de subir el sitio mediante Eclipse, el contenedor est\u00e1 con\ufb01gurado para levantar el proyecto y generar los recursos necesarios para publicar el sistema y as\u00ed puede ser accedido mediante http.","title":"Instalar aplicaciones en Tomcat"},{"location":"modulos/mod_4/mod4_uni001/#cambiar-puerto-de-tomcat","text":"Hay ocasiones, en que el puerto por defecto de Tomcat no es posible utilizarlo( 8080 ), o simplemente est\u00e1 ocupado por otras aplicaciones. La soluci\u00f3n es cerrar esas aplicaciones para liberar el puerto, pero existe otra alternativa que consta de cambiar el puerto por defecto del contenedor. Macintosh HD\u2069 \u25b8 \u2068Aplicaciones\u2069 \u25b8 \u2068contenedor\u2069 \u25b8 \u2068apache-tomcat-9.0.31\u2069 \u25b8 \u2068conf\u2069 Para generar el cambio, debemos dirigirnos dentro de la carpeta de instalaci\u00f3n de Tomcat en la carpeta: /conf . En la carpeta, debemos ubicar el archivo server.xml el cual tiene las con\ufb01guraciones globales del servidor Tomcat. Ver\u00e1s que es un archivo con bastantes l\u00edneas de c\u00f3digos, en donde lo importante para el cambio de puerto es la l\u00ednea: ... <Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /> ... Simplemente tenemos que cambiar el puerto por defecto a alg\u00fan otro, guardar y reiniciar Tomcat, para utilizar el puerto con\ufb01gurado.","title":"Cambiar puerto de Tomcat"},{"location":"modulos/mod_4/mod4_uni001/#protocolo-http","text":"","title":"Protocolo http"},{"location":"modulos/mod_4/mod4_uni001/#competencias_2","text":"Utilizar protocolos http Entender el concepto de arquitectura web Entender request y response http","title":"Competencias"},{"location":"modulos/mod_4/mod4_uni001/#introduccion_2","text":"Cuando un servidor web genera un request hacia un cliente, por lo general env\u00eda alg\u00fan tipo de contenido para que el navegador lo interprete y lo pueda mostrar al usuario. En la mayor\u00eda de los casos el servidor env\u00eda un set de instrucciones en formato de c\u00f3digo HTML (Hyper Text Markup Languaje). El HTML le indica al cliente c\u00f3mo debe visualizarse el recurso web que fue solicitado. Veremos la base para entender c\u00f3mo funciona el protocolo de transferencia de hiper texto .","title":"Introducci\u00f3n"},{"location":"modulos/mod_4/mod4_uni001/#el-protocolo-http","text":"Sus siglas signi\ufb01can Hyper Text Transfer Protocol , o mejor dicho en espa\u00f1ol Protocolo de transferencia de hipertexto . Toda la interacci\u00f3n entre cliente y servidor es mediante este protocolo de comunicaci\u00f3n . El cliente env\u00eda un http-request y el servidor responde con un http-request . HTTP es un protocolo perteneciente a la capa de aplicaci\u00f3n y corre sobre otro protocolo llamado TCP. Es un protocolo ampliable, lo que signi\ufb01ca que en su evoluci\u00f3n ha sido capaz de transmitir no solo p\u00e1ginas web mediante html, si no que tambi\u00e9n es capaz de transmitir im\u00e1genes, audio, video, etc.","title":"El protocolo http"},{"location":"modulos/mod_4/mod4_uni001/#el-modelo-requestresponse-en-http","text":"El protocolo http, y todos los protocolos que est\u00e1n basados en \u00e9l, est\u00e1n construidos bajo el mismo modelo de comunicaci\u00f3n. Este modelo de comunicaci\u00f3n trabaja de la siguiente manera: Un cliente, t\u00edpicamente un navegador web, env\u00eda un request para que el servidor le devuelva cierto recurso. Cuando el server recibe el request, lo analiza, lo gestiona para luego enviar de vuelta un objeto response.","title":"El modelo request/response en HTTP"},{"location":"modulos/mod_4/mod4_uni001/#mensajes-http-request","text":"Veamos un ejemplo de request, en este caso inspeccionamos la p\u00e1gina de Desaf\u00edo Latam , para veri\ufb01car c\u00f3mo se env\u00eda la petici\u00f3n mediante http. En este ejemplo hacemos seguimiento a un archivo .css. Para abrir la consola del desarrollador, debes pinchar con bot\u00f3n derecho sobre la p\u00e1gina web y buscar la opci\u00f3n Inspeccionar. Al momento de presionar la opci\u00f3n, se abrir\u00e1 un sector en la parte inferior de la pantalla, con una serie de herramientas \u00fatiles para los desarrolladores: En el sector izquierdo, se puede apreciar el c\u00f3digo html que el navegador interpret\u00f3. Sirve mucho para veri\ufb01car las posiciones de tus elementos e inspeccionar errores de c\u00f3digo. Para poder ver los contenidos de los request y response de la p\u00e1gina web, debes pinchar la pesta\u00f1a Network y en su pantalla principal, al lado izquierdo en la columna name, seleccionar el recurso que se desea comprobar Al seleccionarlo, se ver\u00e1 toda la informaci\u00f3n del request en el lado derecho de la pantalla. Con esos pasos es posible investigar la mayor\u00eda de elementos que hacen que la p\u00e1gina web se despliegue. Vemos que la secci\u00f3n general, contiene una direcci\u00f3n URL, la cual est\u00e1 formada por: El protocolo La direcci\u00f3n del servidor La ubicaci\u00f3n del archivo css solicitado. Miremos la imagen de nuevo, vemos un sector que tiene el t\u00edtulo de REQUEST METHOD y su valor es GET . El valor get es un verbo http, y aparte del anterior existen varios m\u00e1s. Un verbo se utiliza para indicar de qu\u00e9 forma el request pide el recurso (m\u00e1s adelante veremos los verbos). Podemos ver tambi\u00e9n la direcci\u00f3n remota del servidor y la url de destino.","title":"Mensajes http-Request"},{"location":"modulos/mod_4/mod4_uni001/#mensaje-http-response","text":"Luego de generar un request a un servidor remoto, este nos devuelve nuestro recurso. La siguiente imagen muestra como es la respuesta: Lo importante de aqu\u00ed, es que el request internamente nos entrega bastante informaci\u00f3n sobre el recurso como: M\u00e9todo de respuesta, en este caso GET Content Type, en este caso un archivo .css La fecha.","title":"Mensaje http-response"},{"location":"modulos/mod_4/mod4_uni001/#codigos-de-error-http","text":"Los request y los response vienen con un c\u00f3digo de respuesta, el cual es generado por el servidor para indicar el resultado de los mensajes. HTTP, de\ufb01ne varios c\u00f3digos de error, pero los m\u00e1s conocidos son: C\u00f3digo de respuesta HTTP Ejemplo de c\u00f3digo de error IBM\u00ae Ejemplo de descripci\u00f3n 200 OK Ninguno Se ha manejado correctamente una solicitud v\u00e1lida y, opcionalmente, se ha proporcionado una respuesta al usuario. 202 Accepted Ninguno Se ha manejado correctamente una solicitud v\u00e1lida pero no garantiza que la acci\u00f3n solicitada se haya completado. 400 Bad Request BFGWI0001 El URI no es v\u00e1lido porque le falta un tipo de recurso. 403 Forbidden BFGWI0056 No se ha de\ufb01nido ning\u00fan identi\ufb01cador de usuario. 404 Not Found BFGWI0015 No se puede encontrar el recurso solicitado. 405 Method Not Allowed BFGWI0016 El recurso solicitado no da soporte al verbo HTTP que se ha utilizado en la solicitud.Por ejemplo, se ha utilizado GET con un recurso que s\u00f3lo permite POST o DELETE. 410 Resource Gone BFGWI0031 El recurso solicitado ya no est\u00e1 disponible. Por ejemplo, el archivo solicitado ha sido suprimido del espacio de archivos. 413 Request Entity Too Large BFGWI0026 La solicitud contiene un archivo que es demasiado grande para ser manejado por el servidor. 415 Unsupported Media Type BFGWI0017 Se ha recibido una solicitud con un tipo de medio, especi\ufb01cado por la cabecera HTTP Content-type, que no est\u00e1 soportado. 500 Internal Server Error BFGWI0018 Se ha encontrado un error interno al gestionar la solicitud. Se ha producido un archivo FFDC o ABEND. (Archivos que genera IBM para manejar los errores). 502 Bad Gateway BFGWI0019 La solicitud no se puede completar porque se ha producido un error. 503 Service Unavailable BFGWI0020 El destino no est\u00e1 disponible temporalmente. 504 Gateway Timeout BFGWI0021 Un intento de completar la solicitud ha sobrepasado el tiempo de espera debido a los l\u00edmites de tiempo. Todos estos c\u00f3digos de error son generados de forma autom\u00e1tica por el servidor, y nos permite como desarrolladores saber cual es el tipo de problema que est\u00e1 afectando el correcto funcionamiento de nuestros sistemas . Por ejemplo, pensemos que nuestro sitio web tiene un banner con la imagen de nuestra empresa y necesitamos que se despliegue, pero por alg\u00fan motivo ajeno a nosotros, tal imagen se borr\u00f3 del servidor. El servidor detectar\u00e1 que el recurso que estamos pidiendo no existe y autom\u00e1ticamente enviar\u00e1 un error 404. Nosotros recibimos el c\u00f3digo de error y podemos avisar al usuario mediante alg\u00fan mensaje o alguna otra acci\u00f3n.","title":"C\u00f3digos de error http"},{"location":"modulos/mod_4/mod4_uni001/#la-url","text":"Su sigla signi\ufb01ca Uniform Resource Locators , y se encarga de identi\ufb01car las direcciones en donde se alojan los recursos web. Veamos su estructura: https://www.desafiolatam.com:8927/java/inicio Https: Indica al navegador el protocolo que utiliza en el requerimiento. En este ejemplo es https://www.desafiolatam.cl: direccion_del_servidor . Es la ubicaci\u00f3n f\u00edsica de la m\u00e1quina en la cual esta alojado el sitio. Puerto: puerto de escucha del servidor. Path: Es la ubicaci\u00f3n f\u00edsica de los documentos que estamos solicitando, en el servidor.","title":"La URL"},{"location":"modulos/mod_4/mod4_uni001/#introduccion-a-los-servlets","text":"","title":"Introducci\u00f3n a los servlets"},{"location":"modulos/mod_4/mod4_uni001/#competencias_3","text":"Conocer la teor\u00eda detr\u00e1s de los servlets. Conocer el ciclo de Vida de los servlets. Aplicar ejemplo de uso del ciclo de vida.","title":"Competencias"},{"location":"modulos/mod_4/mod4_uni001/#introduccion_3","text":"Los servlets, son componentes java que tienen la capacidad de generar contenido web din\u00e1mico mediante request y response http. Esta tecnolog\u00eda extiende las capacidades de un sistema web que reside dentro de un contenedor web , el cual le otorga una serie de servicios de plataforma. Utilizando servlets, puedes perfectamente generar una p\u00e1gina web completa solamente con c\u00f3digo java y adem\u00e1s utilizar todo el poder\u00edo de la orientaci\u00f3n a objetos y la vasta biblioteca de clases que ofrece el jdk. Esto se traduce en que puedes armar un sistema web din\u00e1mico, con manejo de variables y funciones java como si fuera una aplicaci\u00f3n de consola, pero con una salida web mediante http y p\u00e1gina html .","title":"Introducci\u00f3n"},{"location":"modulos/mod_4/mod4_uni001/#los-servlets","text":"Como mencionamos hace poco, un servlet no es m\u00e1s que una clase java que trabaja dentro de un contenedor de servlets como Apache Tomcat, el cual es el encargado de extender la funcionalidad de la clase y darle m\u00e1s \"poder\" por decirlo de una forma. El servlet fuera del contenedor Tomcat pierde todo su poder y se convierte en un archivo de texto m\u00e1s , con extensi\u00f3n java imposible de ejecutar, ya que esta clase no cuenta con un m\u00e9todo \"Main\" que ejecute la rutina. Para gra\ufb01car el \ufb02ujo de trabajo de una petici\u00f3n web, pensemos en una p\u00e1gina web que solicita alg\u00fan tipo de recurso (puede ser desde un formulario web hasta una galer\u00eda de fotos, como tambi\u00e9n el c\u00e1lculo del iva de alg\u00fan valor) a un servlet. El servlet recibe la petici\u00f3n mediante el protocolo HTTP y hace su trabajo (puede ser crear los campos del formulario web, ir a buscar una imagen de la galer\u00eda de fotos o hacer el c\u00e1lculo del iva, etc...) para luego mediante el response (la respuesta) devuelve el recurso al navegador. La imagen, muestra el \ufb02ujo normal de petici\u00f3n entre clientes (navegador web) y servidor (contenedor de servlets, aqu\u00ed est\u00e1n los servlets). Esta es, la arquitectura t\u00edpica de un sistema web, la cual es conocida como cliente-servidor .","title":"Los servlets"},{"location":"modulos/mod_4/mod4_uni001/#ciclo-de-vida-de-un-servlet","text":"El ciclo de vida completo de un servlet es administrado por el contenedor de servlet y, antes de empezar a programarlos, hay que entender c\u00f3mo funciona la creaci\u00f3n y el funcionamiento de estos elementos de software. El ciclo de vida se divide en 4 pasos bien de\ufb01nidos: Carga del servlet. Inicializaci\u00f3n del servlet. Captura del request. Destrucci\u00f3n el request.","title":"Ciclo de vida de un Servlet"},{"location":"modulos/mod_4/mod4_uni001/#carga-del-servlet","text":"La primera etapa del ciclo de vida de un servlet parte con su inicializaci\u00f3n gracias al servidor Tomcat. El servidor ejecuta dos pasos en esta etapa: Loading : Carga de la clase servlet Instantiation : Creaci\u00f3n de una instancia del servlet. Para crear una nueva instancia del servlet, el contenedor utiliza un constructor sin par\u00e1metros.","title":"Carga del servlet"},{"location":"modulos/mod_4/mod4_uni001/#inicializacion-de-servlets","text":"Despu\u00e9s de que el servlet fue instanciado correctamente, el contenedor se encarga inicializarlo. \u00c9sto lo realiza invocando al m\u00e9todo Servlet.init() , que acepta la referencia del objeto ServletCon\ufb01g como par\u00e1metro. El m\u00e9todo Servlet.init() es invocado por el servidor solamente una vez, inmediatamente despu\u00e9s de que el objeto Servlet.init(ServletConfig) sea instanciado correctamente. En caso de que el servlet falle en su inicializaci\u00f3n, el contenedor lanza las excepciones: ServletException y UnavailableException .","title":"Inicializaci\u00f3n de Servlets"},{"location":"modulos/mod_4/mod4_uni001/#captura-del-request","text":"Despu\u00e9s de la inicializaci\u00f3n, la instancia del servlet est\u00e1 lista para atender los request del cliente. El contenedor de servlet realiza las siguientes operaciones cuando la instancia del servlet est\u00e1 lista: Crea los objetos ServletRequest y ServletResponse. Despu\u00e9s de crear los objetos ServletRequest y ServletResponse, se invoca al m\u00e9todo Servlet.service (ServletRequest, ServletResponse) al pasar los objetos de solicitud y respuesta. Mientras el m\u00e9todo service() procesa el request puede lanzar las excepciones ServletException, UnavailableException, e IOException.","title":"Captura del Request"},{"location":"modulos/mod_4/mod4_uni001/#destruir-el-servlets","text":"Cuando el contenedor decide destruir el servlet, ejecuta las siguientes acciones: Permite que todos los subprocesos que se ejecutan actualmente en el m\u00e9todo de servicio de la instancia de Servlet completen sus trabajos y sean liberados. Despu\u00e9s de que los procesos en ejecuci\u00f3n hayan completado sus trabajos, el contenedor Servlet llama al m\u00e9todo destroy() en la instancia de Servlet. Una vez ejecutado el m\u00e9todo destroy() , El Servlet container libera todas las referencias de esta instancia de Servlet para que sea elegible para el garbage collector. Se grafica un ejemplo de un servlet simple en la siguiente imagen.","title":"Destruir el Servlets"},{"location":"modulos/mod_4/mod4_uni001/#creacion-del-primer-servlet","text":"","title":"Creaci\u00f3n del primer servlet"},{"location":"modulos/mod_4/mod4_uni001/#competencias_4","text":"Entender c\u00f3mo se compone un servlet. Compilaci\u00f3n de un servlet. Probar servlets en el contenedor. Conocer los m\u00e9todos de los servlets.","title":"Competencias"},{"location":"modulos/mod_4/mod4_uni001/#introduccion_4","text":"En una arquitectura web, la comunicaci\u00f3n entre cliente y servidor es crucial para un funcionamiento colaborativo, y dentro de la tecnolog\u00eda JEE, un servlet, es uno de los principales actores. Ya estudiamos qu\u00e9 es un servlet y cual es su ciclo de vida, por lo que ahora es tiempo de empezar a implementarlos para descubrir poco a poco cuales son sus funciones y que nos permiten hacer.","title":"Introducci\u00f3n"},{"location":"modulos/mod_4/mod4_uni001/#composicion-de-un-servlets","text":"Los servlets se construyen basados en la herencia de su clase padre Http Servlets, clase p\u00fablica y abstracta que permite que una clase herede los m\u00e9todos y atributos que hacen que se convierta en un servlets. La clase que herede de esta clase abstracta, debe sobreescribir al menos: + M\u00e9todo doGet + M\u00e9todo doPost + M\u00e9todo doDelete Esta regla es de oro y, teniendo esto en mente, comenzaremos a generar el primer servlet.","title":"Composici\u00f3n de un servlets."},{"location":"modulos/mod_4/mod4_uni001/#creacion-de-un-servlet","text":"Creamos un nuevo proyecto de tipo Dinamic Web Proyect y nombramos al mismo como PrimerServlet. Avanzamos en el wizard con next y \ufb01nish. Por el momento dejamos las opciones de web.xml por defecto. Al \ufb01nal Eclipse nos genera una estructura de Proyecto, la cual usaremos como base para nuestro trabajo. Por el momento la carpeta importante para nosotros es la Java Resources , que contendr\u00e1 el c\u00f3digo fuente de nuestro programa. Se compone de: La carpeta src , que aloja las clases java y la estructura de paquetes de la aplicaci\u00f3n. La carpeta libraries , que mantiene las librer\u00edas utilitarias. La carpeta build , que mantiene las clases autogeneradas. Luego de generar el Proyecto, vamos a crear nuestra primera clase. Para hacer esta labor, tenemos que seleccionar el nombre del proyecto con bot\u00f3n derecho, y presionar new, class. Una vez creado el proyecto, podemos ver que en: /PrimerServlet/src/cl/lherrera/web/servlets/GeneradorIndex.java package cl.lherrera.web.servlets; public class GeneradorIndex { } Esto por si solo no hace nada, hay que segir trabajandolo. @WebServlet(\"/inicio\"), Es una anotaci\u00f3n, que le indica al contenedor de servlets que esta clase es un servlet, que debe ser accedido mediante URL y su path contenedor es /inicio. Recordemos que un servlet es un componente web que ser\u00e1 accedido por internet, por lo que para ubicar el elemento, debemos llamarlo mediante la direcci\u00f3n url del recurso. El primer m\u00e9todo protected es heredado desde la clase HttpServlet y su nombre es doGet() . Por el momento sabemos que este m\u00e9todo permite devolver una respuesta al navegador del cliente mediante el m\u00e9todo get. El resto del c\u00f3digo es java puro, simplemente estamos generando texto y se lo pasamos a un m\u00e9todo. Algo a destacar es la generaci\u00f3n de c\u00f3digo html en el mismo archivo java. Puedes ver que al imprimir c\u00f3digo estamos generando etiquetas html, las cuales el navegador puede interpretar directamente. El servlet nos queda entonces de la siguiente manera: package cl.lherrera.web.servlets; import java.io.IOException; import java.io.PrintWriter; import java.rmi.ServerException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; @WebServlet(\"/inicio\") public class GeneradorIndex extends HttpServlet { protected void doGet( HttpServletRequest request, HttpServletResponse response) throws IOException, ServerException { // variable de sessi\u00f3n HttpSession session = request.getSession(); // creador de contenido web PrintWriter salida = response.getWriter(); // Texto a imprimir, un alert de Javascript (web) StringBuilder textoWeb = new StringBuilder(\"<script type=\\\"text/javascript\\\">\"); textoWeb.append(\"alert('Hola desde GeneradorIndex !!');\"); textoWeb.append(\"</script>\"); // imprime en el documento HTML salida.println(textoWeb.toString()); return; } } No hay que olvidar poner un index.html , para que cargue por defecto al iniciar el servidor.","title":"Creaci\u00f3n de un servlet."},{"location":"modulos/mod_4/mod4_uni001/#manejo-de-informacion-entre-servlets","text":"","title":"Manejo de informaci\u00f3n entre servlets"},{"location":"modulos/mod_4/mod4_uni001/#competencias_5","text":"Entender el funcionamiento de m\u00e9todos getParams. Enviar par\u00e1metros desde el cliente. Aplicar el env\u00edo de informaci\u00f3n entre servlets.","title":"Competencias:"},{"location":"modulos/mod_4/mod4_uni001/#introduccion_5","text":"Los servlet, no solamente se encarga de devolver recursos a los clientes que lo solicitan, tambi\u00e9n puede comunicarse con otras clases servlets para compartir informaci\u00f3n y articular el \ufb02ujo correcto de un sistema web. Esta capacidad es una gran raz\u00f3n del por que esta tecnolog\u00eda es tan demandada y veremos la forma en la cual estas clases pueden comunicarse entre s\u00ed compartiendo sus variables y dando funcionalidad al sistema.","title":"Introducci\u00f3n"},{"location":"modulos/mod_4/mod4_uni001/#creacion-de-servlet-de-generacion-respuesta","text":"Los servlets tienen la capacidad de recibir par\u00e1metros desde los clientes, para luego procesarlos y generar salidas. El objeto request, es el encargado de manejar tales par\u00e1metros y gracias a \u00e9l, podemos acceder a los datos enviados. Para entender el funcionamiento de esta caracter\u00edstica vamos a implementar una nueva funcionalidad en un ejemplo. En el ejemplo anterior, le sumamos ahora la captura de par\u00e1metros enviados desde el cliente: package cl.lherrera.web.servlets; import java.io.IOException; import java.io.PrintWriter; import java.rmi.ServerException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; @WebServlet(\"/inicio\") public class GeneradorIndex extends HttpServlet { protected void doGet( HttpServletRequest request, HttpServletResponse response) throws IOException, ServerException { // captura de par\u00e1metros String nombre = request.getParameter(\"nombre\"); String apellido = request.getParameter(\"apellido\"); // variable de sessi\u00f3n HttpSession session = request.getSession(); // creador de contenido web PrintWriter salida = response.getWriter(); // Texto a imprimir, un alert de Javascript (web) StringBuilder textoWeb = new StringBuilder(\"<script type=\\\"text/javascript\\\">\"); textoWeb.append(\"alert('Hola \"+ nombre + \" \" + apellido + \" desde GeneradorIndex !!');\"); textoWeb.append(\"</script>\"); salida.println(textoWeb.toString()); return; } } URL: http://localhost:8080/PrimerServlet/inicio?nombre=Luis&apellido=Herrera","title":"Creaci\u00f3n de servlet de generaci\u00f3n respuesta"},{"location":"modulos/mod_4/mod4_uni001/#aplicar-el-envio-de-informacion-entre-servlets","text":"Si bien el \ufb02ujo normal entre un cliente servidor es desde navegador a servidor, hay ocasiones en que se requiere que en la capa de negocio un servlet pueda comunicarse con otro servlet. Para lograr este objetivo, java nos provee de los m\u00e9todos: /** * m\u00e9todo otorgado por HttpRequest, que obtiene el contexto * del servlet que queremos utilizar. */ getRequestDispatcher() /** * luego de obtener el contexto, le enviamos la direcci\u00f3n del servlet. */ getServletContext() Si en nuestro proyecto agregamos otro servlet. Este llamar\u00e1 a nuestro primer servlet, y le pasar\u00e1 el request y response, que le lleg\u00f3. package cl.lherrera.web.servlets; import java.io.IOException; import java.io.PrintWriter; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; @WebServlet(\"/inicio\") public class GeneradorIndex extends HttpServlet { /** * */ private static final long serialVersionUID = 1L; protected void doGet( HttpServletRequest request, HttpServletResponse response) throws IOException { // captura de par\u00e1metros String nombre = request.getParameter(\"nombre\"); String apellido = request.getParameter(\"apellido\"); // variable de sessi\u00f3n HttpSession session = request.getSession(); // creador de contenido web PrintWriter salida = response.getWriter(); // Texto a imprimir, un alert de Javascript (web) StringBuilder textoWeb = new StringBuilder(\"<script type=\\\"text/javascript\\\">\"); textoWeb.append(\"alert('Hola \"+ nombre + \" \" + apellido + \" desde GeneradorIndex !!');\"); textoWeb.append(\"</script>\"); salida.println(textoWeb.toString()); return; } } http://localhost:8080/PrimerServlet/llamainicio?nombre=Luis&apellido=Herrera","title":"Aplicar el env\u00edo de informaci\u00f3n entre Servlets"},{"location":"modulos/mod_4/mod4_uni001/#introduccion-a-los-formularios-y-jtsl-con-jsp","text":"","title":"Introducci\u00f3n a los Formularios y JTSL con JSP"},{"location":"modulos/mod_4/mod4_uni001/#competencias_6","text":"Entender la funci\u00f3n de un formulario. Introducci\u00f3n a la tecnolog\u00eda JSP y JSTL. Instalaci\u00f3n de librer\u00edas JSTL. Aplicar envio de variables entre formularios.","title":"Competencias:"},{"location":"modulos/mod_4/mod4_uni001/#introduccion_6","text":"Los formularios con JSP est\u00e1n hechos con html puro, lo que signi\ufb01ca que no debemos saber nada extra para generar formularios. Lo que s\u00ed hay que tener en cuenta, es el mecanismo para enviar informaci\u00f3n y recibirla entre distintos archivos jsp. Utilizando JSTL es posible f\u00e1cilmente el env\u00edo de valores de formularios mediante m\u00e9todos post o get. Haremos unos ejemplos que gra\ufb01can este mecanismo. Haremos un acercamiento a la tecnolog\u00eda JSTL y a los JSP, pero no ser\u00e1 muy extenso, ya que esta tecnolog\u00eda se tratar\u00e1 en detalle en unidades posteriores. El objetivo real es entender c\u00f3mo es el proceso de envio de informacion entre formularios y servlets.","title":"Introducci\u00f3n"},{"location":"modulos/mod_4/mod4_uni001/#que-es-un-formulario-web","text":"Pensemos un momento en una p\u00e1gina web, con estilos y estructuras que permiten al usuario enterarse de los productos o servicios que una empresa puede ofrecer. Tal p\u00e1gina es solo descriptiva ya que solamente se encarga de desplegar informaci\u00f3n y mostrarla de manera ordenada y atractiva. Pero hay un tema pendiente el cual es la interacci\u00f3n con el usuario . La persona que usa la web no tiene ninguna forma de alimentar con datos al sitio web, y por consiguiente no hay forma de procesar datos ni tampoco de generar conocimientos. Aqu\u00ed entran en juego los formularios web, que son el primer puente entre el usuario y las bases de datos, o la l\u00f3gica real de la empresa . Estos elementos web poseen componentes, que capturan los datos del usuario mediante cajas de texto, listas desplegables, combos de opciones y una serie de componentes html, y gracias a ellos una simple p\u00e1gina web est\u00e1tica se puede convertir en un real sistema web (acompa\u00f1ado de alg\u00fan lenguaje de programaci\u00f3n por el lado del servidor y una base de datos obviamente).","title":"Qu\u00e9 es un formulario web"},{"location":"modulos/mod_4/mod4_uni001/#introduccion-a-los-jsp-y-jstl","text":"","title":"Introducci\u00f3n a los JSP y JSTL."},{"location":"modulos/mod_4/mod4_uni001/#jsp","text":"Java Server Page , m\u00e1s conocido simplemente como jsp, es una tecnolog\u00eda del stack Java JEE que se encarga de proveer herramientas para que los desarrolladores puedan construir p\u00e1ginas web generadas din\u00e1micamente, basadas en el lenguaje de marcado HTML, XML u otro tipo de documentos. Fue lanzado en el a\u00f1o 1999 por Sun Microsystem. Tiene muchas similitudes con otras tecnolog\u00edas como lo son PHP o ASP , pero implementando el lenguaje de programaci\u00f3n Java. Para poder utilizar esta tecnolog\u00eda JSP, es necesario contar con un servidor web compatible con un contenedor de servlets como apache, el cual ya fue utilizado en unidades anteriores. Si analizamos la arquitectura, JSP est\u00e1 basada en el funcionamiento de los servlets, ya que al ser ejecutados, las p\u00e1ginas JSP se convierten internamente en servlets en tiempo de ejecuci\u00f3n , por lo tanto se podr\u00eda decir que una p\u00e1gina JSP es en realidad un servlet . Una p\u00e1gina JSP se puede utilizar utilizando dos mec\u00e1nicas: Como componente de vista de un dise\u00f1o del lado del servidor , trabajando codo a codo con clases Java Bean como el modelo y con servlets como controlador. Posteriormente profundizaremos en la arquitectura cliente servidor. Como un componente independiente , con JSP, podemos incrustar c\u00f3digo java y ciertas acciones prede\ufb01nidas como inicializaci\u00f3n de variables e importaciones en una p\u00e1gina web con HTML (mezclamos contenido din\u00e1mico y contenido est\u00e1tico) . La p\u00e1gina pasa por una etapa de compilaci\u00f3n y ejecuci\u00f3n dentro del servidor para poder entregar un documento . Las p\u00e1ginas compiladas, al igual que las bibliotecas java contienen el c\u00f3digo en formato de ByteCode en vez de c\u00f3digo de m\u00e1quina. Al igual que otro programa en java, el archivo debe ejecutarse dentro de una m\u00e1quina virtual Java (JVM) que interact\u00faa con el sistema operativo host del servidor para proporcionar un entorno neutral para la plataforma. Los JSP se utilizan para generar documentos HTML y XML, pero a trav\u00e9s del uso de OutPutStream, tambi\u00e9n son capaces de entregar otros tipos de datos. El contenedor web, crea objetos JSP impl\u00edcitos como request, response, sesiones, aplicaciones, con\ufb01guraciones, p\u00e1ginas html, salidas y excepciones. El motor de las java Servlets Page crea estos objetos durante la fase de traducci\u00f3n (al igual que los servlets, las p\u00e1ginas JSP tienen el mismo ciclo de vida).","title":"JSP"},{"location":"modulos/mod_4/mod4_uni001/#jstl-javaserver-pages-standard-tag-library","text":"La librer\u00eda JSTL, es un componente dentro de la especificaci\u00f3n del Java 2 Enterprise Edition (J2EE), JSTL no es m\u00e1s que un conjunto de librer\u00edas de etiquetas simples y est\u00e1ndares que encapsulan la funcionalidad principal que es usada com\u00fanmente para escribir p\u00e1ginas JSP. Las etiquetas JSTL est\u00e1n organizadas en 4 librer\u00edas: core : Comprende las funciones script b\u00e1sicas como loops, condicionales, y entrada/salida. xml : Comprende el procesamiento de xml fmt : Comprende la internacionalizaci\u00f3n y formato de valores como de moneda y fechas. sql : Comprende el acceso a base de datos. Utilizando estos componentes, podemos entregar mucha m\u00e1s potencia a nuestros documentos web, por ejemplo, podemos usar un loop de core , para desplegar una grilla, iterando con los resultados.","title":"JSTL (JavaServer Pages Standard Tag Library)"},{"location":"modulos/mod_4/mod4_uni001/#caracteristicas-mas-significativas-de-jstl","text":"JSTL tambi\u00e9n es JSP, siendo un conjunto complementario de este. Utiliza 4 librer\u00edas est\u00e1ndar: SQL, XML, CORE, INTERNALIZACI\u00d3N JSTL de\ufb01ne un nuevo lenguaje de expresiones llamado EL. Al usar una etiqueta JSTL, lo que hacemos en a\u00f1adir una acci\u00f3n. Una etiqueta JSTL est\u00e1 delimitada por ${ } .","title":"Caracter\u00edsticas m\u00e1s signi\ufb01cativas de JSTL"},{"location":"modulos/mod_4/mod4_uni001/#agregar-jstl-a-un-proyecto-manualmente","text":"JSTL, no est\u00e1 en el api oficial, por lo tanto hay que descargarlo, para la descarga utilizamos la siguiente URL: jstl-standard , jstl.jar , jstl-impl.jar . Luego de eso, debemos dejar los archivos en una carpeta en el pc, en mi caso la he dejado en la carpeta aplicaciones junto a Apache Tomcat , pero el destino no importa mientras no eliminemos los jars . Con los archivos en una carpeta, accedemos al proyecto y en las propiedades ir a, Java Build Path, agregar las librer\u00edas externas, aplicar y cerrar. Una vez relizado esto, debemos agregar manualmente las librer\u00edas a /PrimerServlet/WebContent/WEB-INF/lib/ , las tres, simplemente copiando y pegando desde donde las tenemos. Finalmente creamos un archivo JSP , llamado PrimerUsoJstl.jsp , lo creamos en WebContent , con el siguiente contenido: /PrimerServlet/WebContent/PrimerUsoJstl.jsp <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%> <!DOCTYPE html> <html> <head> <meta charset=\"UTF-8\"> <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\"%> <%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\"%> <%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\"%> <%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\"%> <title>Usando JSTL</title> </head> <body> <p>Cadena de caracteres: <strong> <!-- ac\u00e1 se hace uso del core, es como un System.out.println() --> <c:out value=\"1+2+3\" /> </strong> </p> </body> </html> Ejecutamos la aplicaci\u00f3n con el servidor obteniendo el siguiente resultado:","title":"Agregar JSTL a un proyecto (manualmente)"},{"location":"modulos/mod_4/mod4_uni001/#tags-jstl","text":"Para referenciar la librer\u00eda JSTL Core en una p\u00e1gina JSP, debemos declarar la cabecera del documento como a continuaci\u00f3n: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> Lo m\u00e1s signi\ufb01cativo es el prefix=\"c\" , que especi\ufb01ca el tipo de etiqueta y el contexto (conjunto de variables que se poseen, el contexto de la sesi\u00f3n, solamente posee las variables asociadas a la sesi\u00f3n) que se necesita utilizar mediante JSTL. JSTL incluye una gran variedad de tags que engloban distintas \u00e1reas funcionales. Para segmentar estas \u00e1reas, se utilizan namespaces. JSTL expone m\u00faltiples tags en estas url (no son links, son la ubicaci\u00f3n del recurso uri ): Core: http://java.sun.com/jsp/jstl/core XML: http://java.sun.com/jsp/jstl/xml Internationalization: http://java.sun.com/jsp/jstl/fmt SQL: http://java.sun.com/jsp/jstl/sql Functions: http://java.sun.com/jsp/jstl/functions Esta tabla nos expone las opciones disponibles de JSTL:","title":"Tags JSTL"},{"location":"modulos/mod_4/mod4_uni001/#ejemplos-finales","text":"","title":"Ejemplos finales"},{"location":"modulos/mod_4/mod4_uni001/#ejemplo-usando-jstl-uso-de","text":"Creamos un nuevo .jsp : /PrimerServlet/WebContent/ejemplo001.jsp , esto no solamente imprimir\u00e1 una cadena, si no que adem\u00e1s realizar\u00e1 operaciones aritm\u00e9ticas como si lo estubieramos realizando desde Java. <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%> <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %> <%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\" %> <%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %> <%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\" %> <!DOCTYPE html> <html> <head> <meta charset=\"UTF-8\"> <title>Usando JSTL</title> <style> p {} #texto { margin: 0 auto; width: 300px; height: 100px; border: solid 1px black; padding-left: 30px; } #cabecera { margin: 0 auto; width: 300px; border: solid 1px black; padding-left: 30px; background-color: green; color: white; } </style> </head> <body> <div id=\"cabecera\"> <h3>Ejemplos con JSTL salida estandar </h3> </div> <div id=\"texto\"> <p>Cadena de caracteres: <c:out value=\"1+2+3\" /> </p> <p>Suma de caracteres: <c:out value=\"${1+2+3}\" /> </p> </div> </body> </html>","title":"Ejemplo usando JSTL (Uso de ${})"},{"location":"modulos/mod_4/mod4_uni001/#ejemplo-envio-de-valores-entre-jsp","text":"En este ejercicio crearemos un simple formulario, con la entrada de dos valores nombre y apellido, que luego de ser enviados ser\u00e1n recibidos por un jsp con las etiquetas c: out . Es decir que ingresaremos valores en un formulario y estos valores ser\u00e1n luego mostrados. El env\u00edo en este caso, puede ser realizado por get o por post. El verdadero poder de core radica en poder tener acceso a los par\u00e1metros de manera r\u00e1pida y sencilla. Creamos dos archivos `jsp`` /PrimerServlet/WebContent/ejemplo002.jsp /PrimerServlet/WebContent/muestraRespuesta.jsp ejemplo002.jsp <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%> <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %> <%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\" %> <%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %> <%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\" %> <!DOCTYPE html> <html> <head> <meta charset=\"UTF-8\"> <title>Usando JSTL</title> <style> p {} #texto { margin: 0 auto; width: 300px; height: 100px; border: solid 1px black; padding-left: 30px; } #cabecera { margin: 0 auto; width: 300px; border: solid 1px black; padding-left: 30px; background-color: green; color: white; } </style> </head> <body> <div id=\"cabecera\"> <h3>FORMULARIO DE ENV\u00cdO</h3> </div> <div id=\"texto\"> <form action=\"muestraRespuesta.jsp\" method=\"get\"> <label for=\"nombre\">Nombre</label> <input type=\"text\" placeholder=\"Ingrese nombre\" id=\"nombre\" name=\"nombre\"><br /> <label for=\"apellido\">Apellido</label> <input type=\"text\" placeholder=\"Ingrese apellido\" id=\"apellido\" name=\"apellido\"> <input type=\"submit\" value=\"Enviar\"> </form> </div> </body> </html> muestraRespuesta.jsp <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%> <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %> <%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\" %> <%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %> <%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\" %> <!DOCTYPE html> <html> <head> <meta charset=\"UTF-8\"> <title>Usando JSTL</title> <style> p {} #texto { margin: 0 auto; width: 300px; height: 100px; border: solid 1px black; padding-left: 30px; } #cabecera { margin: 0 auto; width: 300px; border: solid 1px black; padding-left: 30px; background-color: green; color: white; } </style> </head> <body> <div id=\"cabecera\"> <h3>Ejemplo JSTL salida estandar</h3> </div> <div id=\"texto\"> <p>Nombre: <c:out value=\"${ param.nombre }\"/></p> <p>Apellido: <c:out value=\"${ param.apellido }\"/></p> </div> </body> </html> Queda de ejercicio hacerlo con bootstrap. Como se ha visto en las pr\u00e1cticas, con el uso de jstl y jsp es muy simple generar una comunicaci\u00f3n \ufb02uida entre elementos de una aplicaci\u00f3n web. Por el momento solo se reviso lo m\u00e1s b\u00e1sico de los tags JSTL , ya que adem\u00e1s de permitir el env\u00edo de datos entre formularios jsp, tambi\u00e9n cuentan con iteraciones, decisiones, tags de manejos de informaci\u00f3n y m\u00e1s, pero para comenzar a entender las arquitecturas y la comunicaci\u00f3n entre componentes es un muy buen comienzo.","title":"Ejemplo: Env\u00edo de valores entre jsp"}]}