


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-5.1.6">
    
    
      
        <title>__Programación orientada a objetos 001__ - Java Full Stack Docs</title>
      
    
    
      <link rel="stylesheet" href="../../../../../assets/stylesheets/main.4b9ffd7b.min.css">
      
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    <body dir="ltr">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#programacion-orientada-a-objetos-001" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../../../../.." title="Java Full Stack Docs" class="md-header-nav__button md-logo" aria-label="Java Full Stack Docs">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            Java Full Stack Docs
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              __Programación orientada a objetos 001__
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../.." title="Java Full Stack Docs" class="md-nav__button md-logo" aria-label="Java Full Stack Docs">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Java Full Stack Docs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../herencia/" title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#estructurar-o-definir-un-nuevo-tipo-de-dato-creacion-de-una-clase" class="md-nav__link">
    Estructurar o definir un nuevo tipo de dato - creación de una clase.
  </a>
  
    <nav class="md-nav" aria-label="Estructurar o definir un nuevo tipo de dato - creación de una clase.">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ejemplo-representacion-de-una-fecha" class="md-nav__link">
    Ejemplo: Representación de una fecha
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setters-amp-getters" class="md-nav__link">
    setters &amp;amp; getters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constructor" class="md-nav__link">
    constructor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tostring" class="md-nav__link">
    toString()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#equalsobject-obj-amp-hashcode" class="md-nav__link">
    equals(Object obj) &amp;amp; hashCode()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#repaso-de-lo-visto" class="md-nav__link">
    Repaso de lo visto
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#resultado-final" class="md-nav__link">
    Resultado final
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nomenclaturas" class="md-nav__link">
    Nomenclaturas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estructura-de-creacion-de-una-clase" class="md-nav__link">
    Estructura de creación de una clase
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ejercicio-clase-vehiculo-vehiculo" class="md-nav__link">
    Ejercicio: Clase Vehículo Vehiculo.
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sobrecarga-de-metodos" class="md-nav__link">
    Sobrecarga de métodos.
  </a>
  
    <nav class="md-nav" aria-label="Sobrecarga de métodos.">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ejemplo-parseador" class="md-nav__link">
    Ejemplo: Parseador
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ejercicio-sumador" class="md-nav__link">
    Ejercicio: Sumador
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sobrecarga-de-constructor" class="md-nav__link">
    Sobrecarga de constructor.
  </a>
  
    <nav class="md-nav" aria-label="Sobrecarga de constructor.">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ejemplo-pelicula" class="md-nav__link">
    Ejemplo: Película.
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ejercicio-usuario-y-rol" class="md-nav__link">
    Ejercicio: Usuario y rol
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modificador-static" class="md-nav__link">
    Modificador static
  </a>
  
    <nav class="md-nav" aria-label="Modificador static">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#demostracion" class="md-nav__link">
    Demostración
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#importacion-de-estaticos" class="md-nav__link">
    Importación de estáticos.
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constructor-privado" class="md-nav__link">
    Constructor privado.
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ejemplo-clase-utilitaria" class="md-nav__link">
    Ejemplo: Clase utilitaria
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  
                
                
                <h1 id="programacion-orientada-a-objetos-001"><strong>Programación orientada a objetos 001</strong></h1>
<ul>
<li>Tenemos que <strong>diferenciar</strong> entre lo que la <strong>clase sabe y lo que la clase hace</strong>.</li>
<li>La clase, es la <strong>definición de un tipo</strong>, de la cual podemos instanciar objetos <strong>para poder utilizar sus servicios</strong>.</li>
<li><strong>Definen, la estructura</strong> de sus objetos. Es decir que <strong>todos los objetos de la misma clase, podrán almacenar el mismo tipo de información y tendrán la misma capacidad para manipularla</strong>.</li>
<li>Una <strong>clase creada por nosotros</strong>, es la definición de <strong>un nuevo tipo de dato que puede o no ser compatible con otro tipo de dato</strong>. Para configurar esta compatibilidad, existen técnicas como el polimorfismo.</li>
<li>Una clase en java está formada por:<ul>
<li><strong>Atributos</strong>: (o campos/propiedades) Almacenan algún tipo de información del objeto. <strong>Definen su estado.</strong></li>
<li><strong>Constructor(es)</strong>: Método que se utiliza para <code>inicializar</code> un objeto.</li>
<li><strong>Métodos</strong>: Son utilizados para <strong>modificar o consultar el estado de un objeto</strong>. Equivalentes a las <strong>funciones</strong> o <strong>procedimientos</strong> de otros lenguajes.</li>
<li>En Java solo hay <strong>dos excepciones al uso de objetos</strong> (<strong>primitivos y arreglos</strong>), además de estos podemos utilizar variables primitivas como <code>int</code>, <code>boolean</code>, etc. y <code>arrays</code> como <code>int[]</code>, <code>boolean[]</code>, etc..</li>
</ul>
</li>
<li>En Java, todo es un objeto</li>
<li><strong>Un programa es un montón de objetos que se dicen entre sí, lo que tienen que hacer enviándose mensajes</strong>.</li>
<li><strong>Cada objeto tiene su propia memoria formada por otros objetos</strong>.</li>
<li><strong>Todo objeto tiene un tipo asociado.</strong></li>
<li><strong>Todos los objeto de un tipo particular, pueden recibir los mismos mensajes. (polimorfismo)</strong>.</li>
<li><strong>Todo objeto tiene una interfaz (sus métodos públicos)</strong>.</li>
<li><strong>Composición de clases v/s Herencia (composición siempre se pueda).</strong></li>
<li>Relación <strong>es un</strong> v/s <strong>es como un</strong>. Se supone que cuando creemos una herencia, se supone que esta clase hija no posee métodos nuevos. Métodos que no sean especificados en la clase padre pero que estén en la clase hija, limita el polimorfismo, a menos que estos métodos extras sean implementaciones de una interfaz u otro tipo que pueda ejecutar estos métodos sin tener que crear una instancia diréctamente la clase.</li>
<li>Cuando se aplica el polimorfismo, el compilador sabrá en tiempo de ejecución, el método que ejecutará. ya que es en este momento cuando se sabe qué clase es la que se ha cargado. (<code>Upcasting</code>: Tratar un objeto derivado como un tipo base <code>List&lt;String&gt; nombres = new ArrayList&lt;&gt;()</code>).</li>
</ul>
<h2 id="estructurar-o-definir-un-nuevo-tipo-de-dato-creacion-de-una-clase"><strong>Estructurar o definir un nuevo tipo de dato - creación de una clase.</strong></h2>
<h3 id="ejemplo-representacion-de-una-fecha"><strong>Ejemplo: Representación de una fecha</strong></h3>
<ul>
<li>Primera parte: Estructurar clases, sobrescribir métodos heredados. Instanciar e imprimir.</li>
<li>Creamos una clase, Fecha (mayúscula para las clases), Esta clase tendrá tres atributos: <code>dia</code>, <code>mes</code>, <code>anio</code>.</li>
</ul>
<p>Fecha.java</p>
<pre><code class="java">package cl.lherrera.primero;

public class Fecha {
    private String dia;
    private String mes;
    private String anio;

}
</code></pre>

<p>Principal.java</p>
<pre><code class="java">package cl.lherrera.primero;

public class Principal {
    public static void main(String[] args) {
        Fecha fecha = new Fecha();

        System.out.println(fecha.dia);
    }
}
</code></pre>

<pre><code>Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: 
    The field Fecha.dia is not visible

    at cl.lherrera.primero.Principal.main(Principal.java:8)

</code></pre>

<ul>
<li>Vemos que no se puede acceder a los atributos directamente desde otra clase, ya que posee un modificador de acceso llamado <code>private</code>, significa que puede ser accedido desde su clase y desde ningún otro lugar.</li>
<li>Para poder modificar el estado de la clase, cuando son privadas (debería ser casi siempre), se necesita hacer mediante <code>métodos</code>.</li>
</ul>
<h3 id="setters-amp-getters"><code>setters &amp; getters</code></h3>
<ul>
<li>Agregamos los <code>setters &amp; getters</code>, primero para poder asignar los valores, y luego para poder obtenerlos. </li>
</ul>
<p>Fecha.java</p>
<pre><code class="java">// ...
    public String getDia() {
        return dia;
    }

    public void setDia(String dia) {
        this.dia = dia;
    }

    public String getMes() {
        return mes;
    }

    public void setMes(String mes) {
        this.mes = mes;
    }

    public String getAnio() {
        return anio;
    }

    public void setAnio(String anio) {
        this.anio = anio;
    }
}

</code></pre>

<p>Principal.java</p>
<pre><code class="java">package cl.lherrera.primero;

public class Principal {
    public static void main(String[] args) {
        Fecha fecha = new Fecha();

        System.out.println(fecha.getDia());
    }
}

</code></pre>

<ul>
<li>Podemos asignar los valores, después de crear la clase.</li>
<li>Además podemos imprimir la fecha en un formato de mejor comprensión humana.</li>
</ul>
<pre><code class="java">package cl.lherrera.primero;

public class Principal {
    public static void main(String[] args) {
        Fecha fecha = new Fecha();

        fecha.setDia(&quot;05&quot;);
        fecha.setMes(&quot;06&quot;);
        fecha.setAnio(&quot;2020&quot;);

        System.out.printf(
            &quot;%s/%s/%s&quot;, 
            fecha.getDia(), 
            fecha.getMes(), 
            fecha.getAnio()
        );
    }
}
</code></pre>

<h3 id="constructor"><strong><code>constructor</code></strong></h3>
<ul>
<li>Para poder tener la opción de construir la clase al momento de instanciar, debemos crear un método especial, llamado <strong><code>constructor</code></strong>. Este permite personalizar el estado de un objeto al momento de crear su instancia.</li>
</ul>
<p>Fecha.java</p>
<pre><code class="java">//...
    public Fecha(String dia, String mes, String anio) {
        this.dia = dia;
        this.mes = mes;
        this.anio = anio;
    }
//...
</code></pre>

<p>Principal.java</p>
<ul>
<li>El constructor permite asignar el estado de una clase al momento de su instancia.</li>
</ul>
<pre><code class="java">package cl.lherrera.primero;

public class Principal {
    public static void main(String[] args) {
        Fecha fecha = new Fecha(&quot;05&quot;, &quot;06&quot;, &quot;2020&quot;);

        System.out.printf(
            &quot;%s/%s/%s&quot;,
            fecha.getDia(),
            fecha.getMes(),
            fecha.getAnio()
        );
    }
}

</code></pre>

<h3 id="tostring"><code>toString()</code></h3>
<ul>
<li>
<p>Podemos personalizar la forma de imprimir la representación de la información que presentará.</p>
</li>
<li>
<p>Este es el método que se ejecuta cuando utilizamos <code>System.ou.println(obj.toString);</code></p>
</li>
<li>
<p>Este método sobrescribe el método entregado por <code>Object</code>.</p>
</li>
</ul>
<p>Fecha.java</p>
<pre><code class="java">//...
    @Override
    public String toString() {
        return String.format(
            &quot;%s/%s/%s&quot;,
            this.getDia(),
            this.getMes(),
            this.getAnio()
        );
    }
//...

</code></pre>

<p>Principal.java</p>
<pre><code class="java">package cl.lherrera.primero;

public class Principal {
    public static void main(String[] args) {
        Fecha fecha = new Fecha(&quot;05&quot;, &quot;06&quot;, &quot;2020&quot;);

        System.out.println(fecha);
    }
}

</code></pre>

<h3 id="equalsobject-obj-amp-hashcode"><code>equals(Object obj) &amp; hashCode()</code></h3>
<ul>
<li>Java define si un objeto es igual a otro utilizando estos dos métodos, el primero en ejecutarse es <code>hashCode()</code>, que ejecuta una comparación muy rápida que nosotros definamos que retorne un tipo de objeto <code>,hashCode()</code>, para saber si vale o no la pena ejecutar el <code>equals(Object obj)</code> y finalmente saber si los objetos son iguales o no.</li>
<li>Podemos seguir sobre escribiendo métodos de <code>Object</code>, como el método <code>equals</code>. </li>
<li>Una de las clases de <code>java.util</code>, realiza esta sobrescritura, estamos hablando de la clase <code>String</code>.</li>
<li>El objetivo de este método, es que así como un número es igual a otro si tienen el mismo valor, para el caso de las clases no se puede concluir a priori, si dos objetos son representativamente iguales. Es decir que cuando creamos una clase, podemos programar un método que indique si dos objetos creados a partir de esa clase son iguales o no.</li>
</ul>
<pre><code class="java">//...
    @Override
    public int hashCode() {
        return dia.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        String este = this.toString();
        String ese = &quot;&quot;;

        if(obj != null)
            ese = obj.toString();

        return este.equals(ese);
    }
//...
</code></pre>

<h3 id="repaso-de-lo-visto"><strong>Repaso de lo visto</strong></h3>
<ul>
<li>Toda clase hereda (directa o indirectamente) de la clase <code>Object</code>.</li>
<li>Los métodos (como <code>toString</code>) de la clase <code>Object</code>. son comunes a todas las clases.</li>
<li>"Sobrescribir", significa reescribir el cuerpo de un método que estamos heredando, sin modificar su encabezado(parámetros) ni su prototipo(modificadores).</li>
<li>Los objetos comienzan a ser utilizados luego de ejecutada su instancia, donde el constructor se encarga de iniciar su estado, si no proporcionamos el constructor, Java nos proporciona uno vacío por defecto. En el caso en que se cree cualquier tipo de constructor, el constructor por defecto desaparece, si necesitamos un constructor vacío, este debe ser implementado.</li>
</ul>
<h3 id="resultado-final"><strong>Resultado final</strong></h3>
<p>Principal.java</p>
<pre><code class="java">package cl.lherrera.primero;

public class Principal {
    public static void main(String[] args) {
        Fecha fecha = new Fecha(&quot;05&quot;, &quot;06&quot;, &quot;2020&quot;);
        Fecha fecha2 = new Fecha(&quot;05&quot;, &quot;06&quot;, &quot;2020&quot;);

        System.out.println(fecha.equals(fecha2));

    }
}

</code></pre>

<p>Fecha.java</p>
<pre><code class="java">package cl.lherrera.primero;

public class Fecha {
    private String dia;
    private String mes;
    private String anio;

    public Fecha(String dia, String mes, String anio) {
        this.dia = dia;
        this.mes = mes;
        this.anio = anio;
    }

    public String getDia() {
        return dia;
    }

    public void setDia(String dia) {
        this.dia = dia;
    }

    public String getMes() {
        return mes;
    }

    public void setMes(String mes) {
        this.mes = mes;
    }

    public String getAnio() {
        return anio;
    }

    public void setAnio(String anio) {
        this.anio = anio;
    }

    @Override
    public int hashCode() {
        return dia.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        String este = this.toString();
        String ese = &quot;&quot;;

        if (obj != null)
            ese = obj.toString();

        return este.equals(ese);
    }

    @Override
    public String toString() {
        return String.format(
            &quot;%s/%s/%s&quot;,
            this.getDia(),
            this.getMes(),
            this.getAnio());
    }

}

</code></pre>

<h3 id="nomenclaturas"><strong>Nomenclaturas</strong></h3>
<ul>
<li>Nombres de clases con inicial mayúscula. <code>CamelCase</code>.</li>
<li>Nombres de métodos, ídem anterior; pero no comienzan con mayúsculas, además de entregar en su nombre una descripción muy corta de lo que realiza el método, como <code>sumar(int a, int b)</code>, podemos saber que suma dos números.</li>
<li>Nombres de atributos: Comienzan con minúscula y <code>CamelCase</code>.</li>
<li>Constantes son todas mayúsculas.</li>
</ul>
<h3 id="estructura-de-creacion-de-una-clase">Estructura de creación de una clase</h3>
<ul>
<li>
<p>Una clase se crea dentro de una unidad de compilación, es decir un archivo <code>.class</code>, Dentro de esta unidad de compilación, debe existir una clase pública con el mismo nombre de la unidad de compilación. Adicionalmente, podemos definir más tipos; pero estos no pueden llevar <code>public</code>. Al compilar, esta unidad de compilación, se crean unidades tantas unidades de salida, dependiendo de los tipos que posea esta unidad de compilación.</p>
</li>
<li>
<p>Las clases son agrupadas en paquetes, por este motivo, al principio de este fichero se debe indicar el paquete al que pertenecerá esta clase. Por ejemplo: <code>package</code> ejemplos, si necesitamos clases de otros paquetes podemos agregar luego los import. ejemplo; <code>import java.util.Scanner;</code></p>
</li>
</ul>
<p>Estructura de declaración:</p>
<pre><code class="java">class &lt;clase&gt;  {
    //declaración de atributos
    [visibilidad] [modificadores] &lt;tipo&gt; &lt;atributo&gt; [= valor];
    ...
    //declaración de constructor
    public &lt;clase&gt;(&lt;argumentos&gt;) {
        &lt;instrucciones&gt;;
    }
    //declaración de métodos
    [visibilidad] [modificadores] &lt;tipo&gt; &lt;método&gt;(&lt;argumentos&gt;) {
        &lt;instrucciones&gt;;
    }
    ...
}
</code></pre>

<pre><code>[visibilidad] = public, protected o private
[modificadores] = final, static y abstract
</code></pre>

<h3 id="ejercicio-clase-vehiculo-vehiculo"><strong>Ejercicio: Clase Vehículo <code>Vehiculo</code>.</strong></h3>
<ul>
<li>
<p>Crear un nuevo tipo de dato (o clase) que represente un Vehículo,  que posea los siguientes atributos:</p>
<ul>
<li>Código de motor.</li>
<li>Marca.</li>
<li>Número de puertas.</li>
<li>Año de fabricación.</li>
<li>precio.</li>
</ul>
</li>
<li>
<p>Implementar los atributos (correctamente encapsulados).</p>
</li>
<li>Crear un constructor que inicie los valores de esta clase, es decir, que defina un estado inicial.</li>
<li>Implementar los <code>setters &amp; getters</code>.</li>
<li>Sobrescribir los métodos <code>equals(Object obj) &amp; hashCode()</code><ul>
<li>Pensar en qué haría que dos vehículos sean iguales.</li>
<li>O utilizar las propuestas del IDE.</li>
</ul>
</li>
<li>Sobrescribir el método <code>toString()</code>, para que entregue un resultado como el que se presenta a continuación:</li>
</ul>
<pre><code>Vehículo: Nissan, 5 puertas, año 2018, $ 7.350.000
</code></pre>

<ul>
<li>
<p>Se debe <strong>respetar la estructura del mensaje</strong>, mayúsculas y minúscula, espacios, etc...</p>
</li>
<li>
<p>Implementar la instancia de 4 objetos de este tipo y realizar las siguientes operaciones:</p>
<ul>
<li>Imprimir el detalle de cada Vehículo creado.</li>
<li>Imprimir el promedio de año de estos cuatro vehículos.</li>
</ul>
</li>
<li>Crear otra instancia que contenga un mismo estado y compararla con alguna otra instancia que decidamos igual, además de compararla con una que no es igual. Los resultados deben ser apreciablemente aceptables, Es decir, que cumplan con la igualdad que le asignamos y que esta igualdad sea reconocida.</li>
</ul>
<p><strong>Solución</strong></p>
<p><strong><code>Vehiculo.java</code></strong></p>
<ul>
<li>El <code>equals(Object obj) &amp; hashCode()</code>, lo podemos hacer automáticamente, con eclipse, utilizando los atributos para realizar la comparación que decidamos.</li>
</ul>
<pre><code class="java">package cl.lherrera.primero;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class Vehiculo {

    private String numeroMotor;
    private String marca;
    private Integer numeroPuertas;
    private Integer anioFabricacion;
    private Integer precio;

    public Vehiculo(String numeroMotor, String marca, int numeroPuertas, int anioFabricacion, int precio) {
        this.numeroMotor = numeroMotor;
        this.marca = marca;
        this.numeroPuertas = numeroPuertas;
        this.anioFabricacion = anioFabricacion;
        this.precio = precio;
    }

    private static String formateaPrecio(int precio) {
        String[] arregloDigitos = Integer.toString(precio).split(&quot;&quot;);
        // para poder agregar o remover, ya que asList retorna un tipo especial de lista
        // que posee las reglas de un arreglo.
        List&lt;String&gt; digitos = Arrays.asList(arregloDigitos);

        List&lt;String&gt; resultado = new ArrayList&lt;&gt;(digitos);

        Collections.reverse(resultado);

        int veces = 1;
        int largo = digitos.size();

        for (int i = 0; i &lt; largo; i++) {
            if (veces &gt; 2 &amp;&amp; digitos.size() &gt; 3 &amp;&amp; (i + 1) &lt; largo) {
                resultado.add((i + 1), &quot;.&quot;);
                largo++;
                veces = 0;
            } else {
                veces++;
            }

        }

        Collections.reverse(resultado);

        return resultado.stream().reduce(&quot;&quot;, (a, b) -&gt; a + b);

    }

    private String formateaMarca(String marca) {
        return marca.substring(0, 1).toUpperCase() + marca.substring(1).toLowerCase();
    }

    @Override
    public String toString() {
        return &quot;Vehículo: &quot; + formateaMarca(marca) + &quot;, &quot;
            + Integer.toString(numeroPuertas) + &quot; puertas, &quot;
            + &quot;año &quot; + Integer.toString(anioFabricacion) + &quot;, &quot;
            + &quot;$ &quot; + formateaPrecio(precio);
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((numeroMotor == null) ? 0 : numeroMotor.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Vehiculo other = (Vehiculo) obj;
        if (numeroMotor == null) {
            if (other.numeroMotor != null)
                return false;
        } else if (!numeroMotor.equals(other.numeroMotor))
            return false;
        return true;
    }

    public String getNumeroMotor() {
        return numeroMotor;
    }

    public void setNumeroMotor(String numeroMotor) {
        this.numeroMotor = numeroMotor;
    }

    public String getMarca() {
        return marca;
    }

    public void setMarca(String marca) {
        this.marca = marca;
    }

    public int getNumeroPuertas() {
        return numeroPuertas;
    }

    public void setNumeroPuertas(int numeroPuertas) {
        this.numeroPuertas = numeroPuertas;
    }

    public int getAnioFabricacion() {
        return anioFabricacion;
    }

    public void setAnioFabricacion(int anioFabricacion) {
        this.anioFabricacion = anioFabricacion;
    }

    public int getPrecio() {
        return precio;
    }

    public void setPrecio(int precio) {
        this.precio = precio;
    }

}

</code></pre>

<p><strong><code>Principal.java</code></strong></p>
<pre><code class="java">package cl.lherrera.primero;

import java.util.ArrayList;
import java.util.List;

public class Principal {
    public static void main(String[] args) {
        Vehiculo nissan = new Vehiculo(&quot;9879804375&quot;, &quot;nissan&quot;, 5, 2018, 7350000);
        Vehiculo toyota = new Vehiculo(&quot;9873459844&quot;, &quot;toyota&quot;, 5, 2015, 4000000);
        Vehiculo mazda = new Vehiculo(&quot;0987324584&quot;, &quot;mazda&quot;, 3, 2020, 10000000);
        Vehiculo lexus = new Vehiculo(&quot;9873425987&quot;, &quot;lexus&quot;, 3, 2014, 17500000);
        System.out.println(nissan);
        System.out.println(toyota);
        System.out.println(mazda);
        System.out.println(lexus);

        // promedio de años
        List&lt;Integer&gt; anios = new ArrayList&lt;&gt;();

        anios.add(nissan.getAnioFabricacion());
        anios.add(toyota.getAnioFabricacion());
        anios.add(mazda.getAnioFabricacion());
        anios.add(lexus.getAnioFabricacion());

        System.out.print(&quot;Año promedio: &quot;);
        anios.stream()
            .mapToInt(x -&gt; x)
            .average()
            .ifPresent(x -&gt; System.out.println((int) x));

        // comparando vehículos
        Vehiculo otroNissan = new Vehiculo(&quot;9879804375&quot;, &quot;nissan&quot;, 5, 2018, 7350000);

        System.out.println(
            &quot;nissan es igual a OtroNissan: &quot; +
                nissan.equals(otroNissan));
        System.out.println(
            &quot;nissan es igual a mazda: &quot; +
                nissan.equals(mazda));

    }
}

</code></pre>

<h2 id="sobrecarga-de-metodos"><strong>Sobrecarga de métodos.</strong></h2>
<ul>
<li>Ya que no existen parámetros que sean opcionales, lo que que realizan lenguajes como <code>php &amp; pyhon</code> entre otros. La forma de solventar atributos opcionales, es programar otro método con el mismo tipo de retorno; pero con distintos tipos de parámetros, distinta cantidad de parámetros y tipo de retorno.</li>
</ul>
<h3 id="ejemplo-parseador"><strong>Ejemplo: <code>Parseador</code></strong></h3>
<ul>
<li>El siguiente ejemplo, imprime representaciones de transformaciones que pueda realizar un método <code>parse</code>, que, dependiendo de lo que se le envíe, será el que será ejecutado.</li>
</ul>
<p><code>Parseador</code></p>
<ul>
<li>Al exponer, tratar de ir de método en método entre el principal, y esta clase.</li>
</ul>
<pre><code class="Java">package cl.lherrera;

import java.util.Arrays;
import java.util.List;

public class Parseador {

    public String parse(int a) {
        return Integer.toString(a);
    }

    public int parse(String a) {
        return Integer.parseInt(a);
    }

    public String parse(boolean a) {
        return (a) ? &quot;true&quot; : &quot;false&quot;;
    }

    public String parse(int a, int b) {
        List&lt;Integer&gt; numeros = Arrays.asList(a, b);
        return numeros.toString();
    }

    public String parse(String a, String b) {
        //
        List&lt;String&gt; numeros = Arrays.asList(a, b);
        return numeros.toString();
    }

}

</code></pre>

<p><code>Principal.java</code></p>
<pre><code class="Java">package cl.lherrera;

public class Principal {
    public static void main(String[] args) {
        Parseador parseador = new Parseador();

        // public String parse(int a)
        String numTxt = parseador.parse(3);
        System.out.println(&quot;Clase numTxt: &quot; + numTxt.getClass().getSimpleName());
        System.out.println(&quot;Valor numTxt: &quot; + numTxt);

        // public int parse(String a)
        Integer num = parseador.parse(&quot;3&quot;); // para poder hacer el getClass.        
        System.out.println(&quot;Clase num: &quot; + num.getClass().getSimpleName());
        System.out.println(&quot;Valor num: &quot; + num);

        // public String parse(boolean a)
        String bool = parseador.parse(true); // para poder hacer el getClass.        
        System.out.println(&quot;Clase bool: &quot; + bool.getClass().getSimpleName());
        System.out.println(&quot;Valor bool: &quot; + bool);

        // public String parse(int a, int b)
        String enteros = parseador.parse(1, 89);  
        System.out.println(&quot;Clase enteros: &quot; + enteros.getClass().getSimpleName());
        System.out.println(&quot;Valor enteros: &quot; + enteros);

        // public String parse(int a, int b)
        String enterosTxt = parseador.parse(&quot;7&quot;, &quot;9&quot;);  
        System.out.println(&quot;Clase enterosTxt: &quot; + enterosTxt.getClass().getSimpleName());
        System.out.println(&quot;Valor enterosTxt: &quot; + enterosTxt);
    }
}

</code></pre>

<h3 id="ejercicio-sumador"><strong>Ejercicio: <code>Sumador</code></strong></h3>
<ul>
<li>Implementar una clase en Java llamada <code>Sumador</code>, esta clase posee un servicio llamado <code>aplicar()</code>, este entrega un entero con el resultado de una suma.</li>
<li>Este método siempre retornará un entero.</li>
<li>Debe ser capaz de realizar la suma dado los siguientes argumentos:<ul>
<li>Una cantidad variable enteros. </li>
<li>Una cantidad variable de cadenas de texto, que represente cada una un número (no se manejan excepciones).</li>
<li>Un arreglo primitivo de enteros.</li>
<li>Un lista de enteros <code>List&lt;Integer&gt;</code>.</li>
</ul>
</li>
</ul>
<p>Solución</p>
<p>Sumador.java</p>
<pre><code class="java">package cl.lherrera;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Principal {
    public static void main(String[] args) {
        Sumador suma = new Sumador();

        // t1
        int total = suma.aplicar(1, 2, 3, 4, 5, 6);
        System.out.println(&quot;t1: &quot; + total);

        // t2
        total = suma.aplicar(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;);
        System.out.println(&quot;t2: &quot; + total);

        // t3
        total = suma.aplicar(new int[] {1, 2, 3, 4, 5, 6});
        System.out.println(&quot;t3: &quot; + total);

        // t4
        List&lt;Integer&gt; enteros = new ArrayList&lt;&gt;();
        Collections.addAll(enteros, 1, 2, 3, 4, 5, 6);


        total = suma.aplicar(enteros);
        System.out.println(&quot;t4: &quot; + total);


    }
}

</code></pre>

<p><code>Principal.java</code></p>
<pre><code class="java">package cl.lherrera;

import java.util.ArrayList;
import java.util.List;

public class Sumador {

    /**
     * Este método tiene problemas con el autoboxing que se produce a nivel de
     * máquina virtual ya que pasa de int[] a Integer en tiempo de ejecución no lo
     * realiza el runtime. Es por todo esto que se deben hacer estás
     * transformaciones. Por eso es que no se usa para esta ocación Arrays.asList(),
     * por que el autobox se produce en tiempo de ejecución
     */
    public int aplicar(int... a) {
        List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();
        for (Integer entero : a)
            intList.add(entero);

        return intList.stream().reduce(0, (x, y) -&gt; x + y);
    }

    /**
     * Ya que lo que viene es una serie de números representados por cadenas, estos
     * se deben mapear a enteros, y como solamente los vamos a sumar usamos reduce
     */
    public int aplicar(String... a) {
        List&lt;String&gt; intList = new ArrayList&lt;&gt;();
        for (String entero : a)
            intList.add(entero);

        // si solamente usamos un map, no podemos aplicar un .sum().
        return intList.stream().mapToInt(Integer::parseInt).sum();
    }

    /*
     * acá ya nos llega la lista por parámetro, lo que significa que no hay
     * necesidad de transformaciones, lo que sí, mapToint, es necesario para
     * ejecutar sum, por lo que simplemente, le pasamos x -&gt; x donde dejamos el
     * valor tal y como está. Parece redundante; pero es necesario, si vamos a
     * aplicar funciones matemáticas
     */
    public int aplicar(List&lt;Integer&gt; a) {
        return a.stream().mapToInt(x -&gt; x).sum();
    }
}

</code></pre>

<h2 id="sobrecarga-de-constructor"><strong>Sobrecarga de constructor.</strong></h2>
<ul>
<li>Como el constructor es un método más, solamente que cumple un rol especifico, retornar una instancia de la clase a la que pertenece. Es posible entonces sobrecargarla.</li>
</ul>
<h3 id="ejemplo-pelicula"><strong>Ejemplo: Película.</strong></h3>
<ul>
<li>Dar la capacidad a una clase llamada <code>Pelicula</code>, para que pueda ser inicializada con atributos y además si es que estos no son facilitados.</li>
<li>Los atributos que posee serán: <code>título &amp; duración</code></li>
</ul>
<p><code>Pelicula.java</code></p>
<ul>
<li>Sobrecargamos el constructor para que pueda manejar el hecho que se construya sin argumentos.</li>
</ul>
<pre><code class="java">package cl.lherrera;

public class Pelicula {
    private String titulo;
    private int duracion;

    public Pelicula() {
        this.titulo = &quot;No especificado&quot;;
        this.duracion = 0;
    }

    public Pelicula(String titulo, int duracion) {
        this.titulo = titulo;
        this.duracion = duracion;
    }

    @Override
    public String toString() {
        return &quot;Pelicula [titulo=&quot; + titulo + &quot;, duracion=&quot; + duracion + &quot;]&quot;;
    }

}

</code></pre>

<p><code>Principal.java</code></p>
<pre><code class="java">package cl.lherrera;

public class Principal {
    public static void main(String[] args) {
        // P1
        Pelicula pelicula1 = new Pelicula();
        System.out.println(&quot;P1: &quot; + pelicula1);

        // P2        
        Pelicula pelicula2 = new Pelicula(&quot;El ciempiés humano&quot;, 82);
        System.out.println(&quot;P1: &quot; + pelicula2);
    }
}

</code></pre>

<p>Salida</p>
<pre><code>P1: Pelicula [titulo=No especificado, duracion=0]
P1: Pelicula [titulo=El ciempiés humano, duracion=82]
</code></pre>

<h3 id="ejercicio-usuario-y-rol"><strong>Ejercicio: Usuario y rol</strong></h3>
<ul>
<li>Crear una clase que represente a un usuario, que posea tres atributos:<ul>
<li><code>rol</code>: Representado con dos posibles valores:<ul>
<li><code>ROL_ADMIN</code></li>
<li><code>ROL_USER</code></li>
</ul>
</li>
<li><code>username</code>: Representa el nombre de usuario.</li>
<li><code>password</code>: Representa la contraseña de un usuario.</li>
</ul>
</li>
<li>Llevará tres constructores:<ul>
<li>Uno vacío, que cree por defecto <code>{admin, admin, ROL_USER}</code></li>
<li>Uno que reciba el usuario y contraseña y cree el siguiente valor por defecto <code>{ROL_USER}</code></li>
<li>Uno que reciba el usuario, contraseña y un <code>boolean</code> que en caso de ser <code>true</code> indique el rol <code>ROL_ADMIN</code> y en caso de ser <code>false</code> indicar el rol <code>ROL_USER</code></li>
</ul>
</li>
<li>Debe contener un método que solamente ejecute su contenido si es un administrador:<ul>
<li>En caso de serlo imprimir: "Bienvenido Administrador".</li>
<li>En caso de no serlo imprimir: "Permisos insuficientes"</li>
</ul>
</li>
<li>En la clase principal, creamos una instancia para cada constructor y ejecutamos el método con las restricciones para comprobar su funcionamiento.</li>
</ul>
<p>Solución</p>
<p><code>Usuario.java</code></p>
<pre><code class="java">package cl.lherrera;

public class Usuario {
    private String rol;
    private String username;
    private String password;

    private static final String ADMIN = &quot;ROL_ADMIN&quot;;
    private static final String USER = &quot;ROL_USER&quot;;

    public Usuario() {
        this.username = &quot;admin&quot;;
        this.password = &quot;admin&quot;;
        this.rol = USER;
    }

    public Usuario(String username, String password) {
        this.username = username;
        this.password = password;
        this.rol = USER;
    }

    public Usuario(String username, String password, boolean isAdmin) {
        this.username = username;
        this.password = password;
        this.rol = (isAdmin) ? ADMIN : USER;
    }

    public void administraSistema() {
        if (this.rol.equals(ADMIN))
            System.out.println(&quot;Bienvenido Administrador&quot;);
        else
            System.out.println(&quot;Permisos insuficientes&quot;);
    }

    @Override
    public String toString() {
        return &quot;Usuario [rol=&quot; + rol + &quot;, username=&quot; + username + &quot;, password=&quot; + password + &quot;]&quot;;
    }

}

</code></pre>

<p><code>Principal.java</code></p>
<pre><code class="java">package cl.lherrera;

public class Principal {
    public static void main(String[] args) {
        Usuario usuario1 = new Usuario();
        Usuario usuario2 = new Usuario(&quot;lherrera&quot;, &quot;1234&quot;);
        Usuario usuario3 = new Usuario(&quot;lherrera&quot;, &quot;1234&quot;, true);

        System.out.println(usuario1);
        System.out.println(usuario2);
        System.out.println(usuario3);

        usuario1.administraSistema();
        usuario2.administraSistema();
        usuario3.administraSistema();
    }
}

</code></pre>

<h2 id="modificador-static"><strong>Modificador <code>static</code></strong></h2>
<ul>
<li>Si un atributo o método posee este modificador, significa que le pertenece a la clase y no a una instancia.</li>
<li>Es decir que lo guarda en el lugar donde se guarda la información de la clase, no en el <code>heap</code>.</li>
</ul>
<h3 id="demostracion"><strong>Demostración</strong></h3>
<ul>
<li>Solo expositivo, muestra como es el funcionamiento de los estáticos.</li>
<li>El siguiente ejemplo, muestra, como se comporta un atributo y un método estático.</li>
</ul>
<p><code>Persona.java</code></p>
<pre><code class="java">package cl.lherrera;

public class Persona {
    public static int conteo;

    public static void metodoEstatico() {
        System.out.println(&quot;El conteo lleva: &quot; + conteo);
    }

}

</code></pre>

<p><code>Principal.java</code></p>
<pre><code class="java">package cl.lherrera;

public class Principal {
    public static void main(String[] args) {
        Persona.conteo = 4;
        Persona persona1 = new Persona();
        Persona persona2 = new Persona();
        Persona.conteo = 6;
        Persona.conteo = 5;

        System.out.println(Persona.conteo);
        System.out.println(persona1.conteo);
        System.out.println(persona2.conteo);
        Persona.metodoEstatico();
        persona1.metodoEstatico();
        persona2.metodoEstatico();

        // no importa que instanciemos y asignemos valorea desde otras instancias
        // el valor static, se queda estático en la misma clase, 
        // al igual que sus métodos.
    }
}

</code></pre>

<h3 id="importacion-de-estaticos"><strong>Importación de estáticos.</strong></h3>
<ul>
<li>Los valores estáticos pueden ser importados independientemente de su clase. Es decir que si en una clase tenemos un atributo o método estático, lo podemos llamar sin la necesidad de escribir el nombre de la clase cada vez que queramos utilizarla si realizamos un <code>static import</code></li>
</ul>
<p><code>Principal.java</code></p>
<ul>
<li>Utilizando el ejemplo anterior, realizamos los siguientes cambios y probamos si podemos llamar directamente la llamada al atributo y método estático.</li>
</ul>
<pre><code class="java">package cl.lherrera;

import static cl.lherrera.Persona.conteo;
import static cl.lherrera.Persona.metodoEstatico;

public class Principal {
    public static void main(String[] args) {
        conteo = 4;

        System.out.println(conteo);
        metodoEstatico();

        // se eliminan todas las referencias a Persona
    }
}

</code></pre>

<h3 id="constructor-privado"><strong>Constructor privado.</strong></h3>
<ul>
<li>Este tipo de constructor, realiza la tarea de evitar que se cree una instancia de una clase, ya que posee miembros (atributos y métodos) estáticos, entonces con ello evitamos confusiones como las vistas en el primer ejemplo, donde utilizamos miembros estáticos desde una instancia, lo que no debe ser posible.</li>
</ul>
<p><code>Persona.java</code></p>
<pre><code class="java">package cl.lherrera;

public class Persona {

    // esto evita que se pueda crear una instancia
    private Persona() {}

    public static int conteo;

    public static void metodoEstatico() {
        System.out.println(&quot;El conteo lleva: &quot; + conteo);
    }

}

</code></pre>

<p><code>Principal.java</code></p>
<pre><code class="java">package cl.lherrera;

import static cl.lherrera.Persona.conteo;
import static cl.lherrera.Persona.metodoEstatico;

public class Principal {
    public static void main(String[] args) {
        conteo = 4;

        System.out.println(conteo);
        metodoEstatico();

        Persona persona = new Persona();
        // se eliminan todas las referencias a Persona
    }
}
</code></pre>

<p>Salida</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: 
    The constructor Persona() is not visible

    at cl.lherrera.Principal.main(Principal.java:13)
</code></pre>

<h3 id="ejemplo-clase-utilitaria"><strong>Ejemplo: Clase utilitaria</strong></h3>
<ul>
<li>Muchas veces, el contexto empresarial, influye en las transformaciones que deba presentar la información que obtengamos.</li>
<li>Podríamos por ejemplo, crear un método llamado imprime, que muestre por consola lo que le sea entregado en una cadena de texto.</li>
<li><strong>Implementar dos clases, estas serán utilitarias, compuesta únicamente por miembros estáticos, las clases son:</strong>.</li>
<li><strong>Clase utilitaria <code>Dia</code> con:</strong><ul>
<li>7 atributos estáticos finales, siguiendo la siguiente estructura:<ul>
<li><code>public static final String LUNES = "El día seleccionado es el lunes";</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Clase utilitaria <code>FechaFormat</code></strong><ul>
<li>Esta clase, contiene un método llamado <code>consultaDia(int numDia)</code>, este debe retornar, dependiendo el número que se le asigne, la respuesta correspondiente basada en la clase <code>Dia</code>. </li>
<li>Ejemplo: La llamada a <code>consultaDia(1)</code>, debe retornar: <code>El día seleccionado es el lunes</code></li>
</ul>
</li>
<li>Las llamadas de realizarán desde el main. Las pruebas serán para cada día de la semana.</li>
<li>Se debe controlar que las clases no puedan ser instanciadas, además de realizar una correcta importación estática.</li>
</ul>
<p>Solución</p>
<p><code>Dia.java</code></p>
<pre><code class="java">package cl.lherrera;

public class Dia {
    private Dia() {
    }

    public static final String LUNES = &quot;El día seleccionado es el lunes&quot;;
    public static final String MARTES = &quot;El día seleccionado es el martes&quot;;
    public static final String MIERCOLES = &quot;El día seleccionado es el miércoles&quot;;
    public static final String JUEVES = &quot;El día seleccionado es el jueves&quot;;
    public static final String VIERNES = &quot;El día seleccionado es el viernes&quot;;
    public static final String SABADO = &quot;El día seleccionado es el sábado&quot;;
    public static final String DOMINGO = &quot;El día seleccionado es el domingo&quot;;

}
</code></pre>

<p><code>FechaFormat.java</code></p>
<pre><code class="java">package cl.lherrera;

// o importar: import static cl.lherrera.Dia.*;
import static cl.lherrera.Dia.LUNES;
import static cl.lherrera.Dia.MARTES;
import static cl.lherrera.Dia.MIERCOLES;
import static cl.lherrera.Dia.JUEVES;
import static cl.lherrera.Dia.VIERNES;
import static cl.lherrera.Dia.SABADO;
import static cl.lherrera.Dia.DOMINGO;

public class FechaFormat {
    private FechaFormat() {}

    public static void consultaDia(int numDia){
        switch (numDia) {
        case 1:
                System.out.println(LUNES);
            break;
        case 2:
            System.out.println(MARTES);
            break;
        case 3:
            System.out.println(MIERCOLES);
            break;
        case 4:
            System.out.println(JUEVES);
            break;
        case 5:
            System.out.println(VIERNES);
            break;
        case 6:
            System.out.println(SABADO);
            break;
        case 7:
            System.out.println(DOMINGO);
            break;
        default:
            System.out.println(&quot;código incorrecto&quot;);
            break;
        }
    }
}

</code></pre>

<p><code>Principal.java</code></p>
<pre><code class="java">package cl.lherrera;

import static cl.lherrera.FechaFormat.consultaDia;

public class Principal {
    public static void main(String[] args) {
        consultaDia(1);
    }
}

</code></pre>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../../../../assets/javascripts/vendor.a0c4167b.min.js"></script>
      <script src="../../../../../assets/javascripts/bundle.fb26dd1d.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../../../../..",
          features: [],
          search: Object.assign({
            worker: "../../../../../assets/javascripts/worker/search.37585f48.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>