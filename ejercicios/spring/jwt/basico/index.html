


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-5.1.6">
    
    
      
        <title>Basico - Java Full Stack Docs</title>
      
    
    
      <link rel="stylesheet" href="../../../../assets/stylesheets/main.4b9ffd7b.min.css">
      
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    <body dir="ltr">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#1-ejemplo-basico" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../../../.." title="Java Full Stack Docs" class="md-header-nav__button md-logo" aria-label="Java Full Stack Docs">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            Java Full Stack Docs
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Basico
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../.." title="Java Full Stack Docs" class="md-nav__button md-logo" aria-label="Java Full Stack Docs">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Java Full Stack Docs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../../../repaso/teoria/poo/herencia/" title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#11-notas" class="md-nav__link">
    1.1 Notas
  </a>
  
    <nav class="md-nav" aria-label="1.1 Notas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#111-head-first" class="md-nav__link">
    1.1.1 Head First.
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#12-implementacion" class="md-nav__link">
    1.2 Implementación
  </a>
  
    <nav class="md-nav" aria-label="1.2 Implementación">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jwtappsrcmainjava" class="md-nav__link">
    /jwtapp/src/main/java
  </a>
  
    <nav class="md-nav" aria-label="/jwtapp/src/main/java">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cllherrerajwtapp" class="md-nav__link">
    cl.lherrera.jwtapp
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherrerajwtappapiexception" class="md-nav__link">
    cl.lherrera.jwtapp.apiexception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherrerajwtappconfig" class="md-nav__link">
    cl.lherrera.jwtapp.config
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherrerajwtappcontroller" class="md-nav__link">
    cl.lherrera.jwtapp.controller
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherrerajwtappdao" class="md-nav__link">
    cl.lherrera.jwtapp.dao
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherrerajwtappdto" class="md-nav__link">
    cl.lherrera.jwtapp.dto
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherrerajwtappmapper" class="md-nav__link">
    cl.lherrera.jwtapp.mapper
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherrerajwtappmodel" class="md-nav__link">
    cl.lherrera.jwtapp.model
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherrerajwtappsecurity" class="md-nav__link">
    cl.lherrera.jwtapp.security
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherrerajwtappservice" class="md-nav__link">
    cl.lherrera.jwtapp.service
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jwtappsrcmainresources" class="md-nav__link">
    /jwtapp/src/main/resources
  </a>
  
    <nav class="md-nav" aria-label="/jwtapp/src/main/resources">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#applicationproperties" class="md-nav__link">
    application.properties
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#databaseproperties" class="md-nav__link">
    database.properties
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jwtapppomxml" class="md-nav__link">
    /jwtapp/pom.xml
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  
                
                
                <blockquote>
<h1 id="1-ejemplo-basico">1 Ejemplo básico</h1>
<blockquote>
<ul>
<li>Proyecto posee errores de negocio, como no poseer un objeto estándar de retorno, ya que hay veces en que se retorna un a cadena y otras un json, estas están "algunas" solucionadas en el siguiente proyecto.</li>
<li>Implementar el retorno del <code>token</code>, en un campo que se llame <code>data</code>, y el status, para no tener ambigüedades al momento de esperar un tipo <code>json</code> y un <code>plain string</code>. Es mejor estandarizar la información que se usará de interfaz</li>
<li>La siguiente aplicación, muestra la utilización de un ejemplo básico del uso de JWT.</li>
<li>Se puede registrar un usuario, listarlo e ingresarlo, con restricciones de acceso a listar.</li>
<li>Se puede personalizar el campo que usamos como <code>username</code> o el <code>password</code>, el tipo de dato encargado de controlar la seguridad en <code>Spring</code> lo puede manejar; pero para hacerlo necesitamos <code>http.formLogin().usernameParameter("correo")</code>, y esto está más bien pensado para funcionar con <code>MVC</code>.</li>
<li>Se descarta el punto anterior ya que el acceso basado en formularios, altera el uso de la API, por ejemplo, en el caso de un error en el
intento de autenticación, nos llevaría a la página de login, lo que en el caso de estar siendo consumida, no serviría una respuesta en `html``
con la página de inicio de sesión en reemplazo de la que se tiene en el Front.</li>
<li>El uso de <code>@Controller</code> no será necesario, no retornamos vistas, retornamos <code>Json</code> y <code>txt</code>. Es por eso que usaremos <code>@RestController</code>.</li>
</ul>
</blockquote>
</blockquote>
<hr />
<p><br /></p>
<blockquote>
<h2 id="11-notas"><strong>1.1 Notas</strong></h2>
</blockquote>
<h3 id="111-head-first"><strong>1.1.1 Head First</strong>.</h3>
<p>Para poder implementar la seguridad en nuestra aplicación usando <code>JWT</code>, debemos cumplir con las siguientes reglas:</p>
<ul>
<li>Se necesita identificar un <code>username</code> y un <code>password</code>, aunque nuestros campos en la base de datos se llamen de forma distinta, esto lo personalizamos en el modelo, como es el caso de este ejemplo, donde nuestro <code>username</code> se llama <code>correo</code>. y el <code>password</code> se llama <code>contrasenia</code>.</li>
<li>Se necesitan implementar las siguientes clases para la administración de la seguridad:<ul>
<li><strong><code>JwtTokenFilter</code></strong>: Extiende de <code>OncePerRequestFilter</code>, es decir, que implementará los métodos necesarios para que <code>por cada request</code> este filtro será aplicado. El método a implementar es <code>doFilterInternal</code>, que se le debe implementar una lógica para que cree un usuario autenticado si es que el token dado es válido, en caso contrario no se crea a este usuario.</li>
<li><strong><code>JwtTokenProvider</code></strong>: No extiende de otra clase y proporciona los servicios del <code>token</code> como lo son:<ul>
<li><code>init</code>: Inicia el valor de la clave secreta, cuando se crea este objeto, justo después (de la construcción) gracias a su anotación <code>@PostConstruct</code>.</li>
<li><code>createToken</code>: Utilizando el nombre de usuario y la lista de los roles, se creará un <code>token</code> con las condiciones de validez que le indiquemos, como por ejemplo, el tiempo de duración entre otras personalizaciones, veremos algunos de estos datos en el archivo de propiedades de la aplicación.</li>
<li><code>getAuthentication</code>: Es el método que es llamado cuando el <code>JwtTokenFilter</code>, crea el objeto <code>Authentication</code> luego de comprobar si el <code>token</code> es válido o no <code>if (token != null &amp;&amp; jwtTokenProvider.validateToken(token))</code> (extracto de implementación en <code>JwtTokenFilter</code>).</li>
<li><code>getUsername</code>: Método que obtiene información del usuario que viene en el <code>token</code>, gracias a <code>parseClaimsJws</code>, en este caso, tenemos el nombre del usuario. Piensen en la necesidad de disponer de información del usuario en linea, en una sesión sin estado. Solamente el token mantiene este estado y la información del usuario autenticado está allí, este método se encarga de extraer esta información.</li>
<li><code>resolveToken</code>: Se resuelve el <code>"Bearer "</code>, recordando que <code>Authorization: Bearer &lt;access_token&gt;</code> el verdadero token es <code>&lt;access_token&gt;</code>el <code>Bearer</code>, es nuestro transportador que por defecto es <code>Bearer</code>, pero podría cambiar y lo resolveríamos en la implementación de este método, además de personalizar el nombre del campo del <code>Header</code>, que en este caso será <code>Authorizacion</code> y no <code>Authorization</code>. Lo que en realidad debe hacer es recuperar el token puro, sin el <code>Bearer</code>.</li>
<li><code>validateToken</code>: Si el token logra ser <code>parseado</code>, entonces se asume que es un <strong>Token válido</strong>. <code>parseClaimsJws</code> analiza la llave (no un token que exista hipotéticamente, la comparación se realiza entre el token que está en el <code>request</code> y la <code>clave cifrada</code>, de esta clase, cifrada justo después de construirse este objeto usando <code>init</code> ).</li>
</ul>
</li>
<li><strong><code>JwtTokenFilterConfigurer</code></strong>: Extiende de <code>SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt;</code> , que es un adaptador de la seguridad de <code>Spring security - SecurityConfigurer + SecurityBuilder</code>, este último posee un método <code>configure(HttpSecurity http)</code> sobrecargado que al recibir un tipo <code>HttpSecurity</code> por cada <code>request</code> encadenará el <code>JwtTokenFilter</code> justo antes de <code>UsernamePasswordAuthenticationFilter</code>y que tiene como misión verificar en cada petición antes de que se pida el usuario, crearlo con la información contenida en el token.</li>
<li><strong><code>WebSecurityConfig</code></strong>: Extiende de <code>WebSecurityConfigurerAdapter</code> otro adaptador como <code>SecurityConfigurerAdapter</code>; pero con más funcionalidad, también posee un método <code>protected void configure(HttpSecurity http)</code>, pero a diferencia del que se sobre escribe en <code>SecurityConfigurerAdapter</code>, el de <code>WebSecurityConfigurerAdapter</code> que sobre escribimos acá, posee el modificador de acceso <code>protected</code>, lo que hace que realmente no sea el mismo método. Y así es ya que el anterior, posee un <code>DefaultSecurityFilterChain</code>, lo que no es el caso del <code>configure</code> que está presente en esta clase. En pocas palabras, el <code>configure</code> de <code>WebSecurityConfigurerAdapter</code> tiene la posibilidad de entregar o no accesos a diferentes <code>endspoints</code> según los privilegios que posea un usuario. ( roles, si está autenticado, si no) además de efectuar acciones como redirigir a ventanas en caso de fallos en el inicio de sesión. a diferencia de el otro <code>configure</code> público, que ya sabemos, efectúa una validación del token en cada petición, este filtro se añade a esta configuración WEB justo en: <code>http.apply(new JwtTokenFilterConfigurer(jwtTokenProvider) );</code>, y es el <code>jwtTokenProvider</code> inyectado por <code>Spring</code> justo en esta clase, con que trabajarán las clases anteriores que lo posean como atributo, y es por eso, que es inyectado acá y no en las otras clases. Finalmente, esta configuración tendrá además del control de acceso a los servicios, si no que tendrá un filtro por token que en caso de venir y ser válido, permitirá el acceso al recurso o retornará un código de error. Este tipo, consume dependencias de <code>Spring Security</code>, la dependencia de <code>jjwt</code> son solamente para la generación del token por ejemplo <code>Jwts.builder</code>, pero el <code>configurer</code> forma parte de <code>Spring Security</code>.</li>
</ul>
</li>
<li>Además de las siguientes condiciones para la administración del usuario y contraseña como servicios.<ul>
<li>Se debe tener una tabla para el manejo de usuarios y debe contar con al menos tres campos:<ul>
<li>Un campo <code>String</code> que maneje al usuario llamado <code>username</code> (el nombre no es obligatorio podemos usar otro nombre en la base de datos, como vemos en el ejemplo que el campo en la base de datos se llama <code>correo</code>, mientras que el campo realmente en la entidad se llama <code>username</code>) .</li>
<li>Un campo <code>String</code> que maneje la contraseña. Con las mismas posibilidades de personalización que se indican en el punto anterior.</li>
<li>Un campo <code>List&lt;EntidadRol&gt;</code> con la anotación <code>@ElementCollection(fetch = FetchType.EAGER)</code> para que se maneje la relación en la base de datos, donde veremos que cuando lo ejecutamos se crea una tabla intermedia con la información entre usuarios y roles. Por lo demás contiene todo lo que posee un <code>pojo</code> o mejor dicho, un <code>bean</code>.</li>
</ul>
</li>
<li>Una clase que maneje los roles, de tipo <code>Enum</code>, que posea la lista de tipos posibles, como roles. En una aplicación, todos los tipos de listas cortas, deberían ser tratados de esta forma, si estamos seguros que la lista no será larga. Extiende de <code>GrantedAuthority</code>, que al sobre escribir el método: <code>getAuthority()</code> es capaz de obtener el rol. En la tabla intermedia que existirá en la base de datos, veremos un número que representa el índice del tipo en la lista <code>Enum</code>, donde: <code>ROLE_ADMINISTRADOR</code>, sería el <code>0</code>.</li>
</ul>
</li>
<li>El servicio que atienda esta interfaz, en el caso del ejemplo <code>ServicioUsuario</code>, <strong>debe extender de <code>UserDetailsService</code></strong> que posee un método <code>loadUserByUsername</code>, este método, es capaz de crear un <code>UserDetails</code> con el nombre de usuario. En el ejemplo, es el <code>correo</code>. Como es la capa de servicio, se habla aún con la jerga de negocio y el <code>username</code> es llamado <code>correo</code>. Este <code>UserDetails</code>, es usado por el <code>JwtTokenProvider</code> inyectado por <code>Spring</code> en su método<code>Authentication getAuthentication(String token)</code> para poder crear el usuario con la información del token. (de esta forma, en una sesión sin estado, se transporta la información que contiene el token de manera encriptada, como por ejemplo el nombre de usuario o sus credenciales).</li>
</ul>
<p><br /></p>
<blockquote>
<h2 id="12-implementacion"><strong>1.2 Implementación</strong></h2>
</blockquote>
<h3 id="jwtappsrcmainjava"><strong><code>/jwtapp/src/main/java</code></strong></h3>
<h4 id="cllherrerajwtapp"><strong><code>cl.lherrera.jwtapp</code></strong></h4>
<p><strong><code>JwtappApplication.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class JwtappApplication {

    public static void main(String[] args) {
        SpringApplication.run(JwtappApplication.class, args);
    }

}

</code></pre>

<h4 id="cllherrerajwtappapiexception"><strong><code>cl.lherrera.jwtapp.apiexception</code></strong></h4>
<p><code>RestServiceException.java</code></p>
<pre><code class="java">package cl.lherrera.jwtapp.apiexception;

import org.springframework.http.HttpStatus;

public class RestServiceException extends RuntimeException {

    private static final long serialVersionUID = 5037553749745142029L;

    private final String message;
    private final HttpStatus httpStatus;

    public RestServiceException(String message, HttpStatus httpStatus) {
        super();
        this.message = message;
        this.httpStatus = httpStatus;
    }

    @Override
    public String getMessage() {
        return message;
    }

    public HttpStatus getHttpStatus() {
        return httpStatus;
    }

}

</code></pre>

<h4 id="cllherrerajwtappconfig"><strong><code>cl.lherrera.jwtapp.config</code></strong></h4>
<p><strong><code>AppConfig.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.config;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

@Configuration
@ComponentScan(&quot;cl.lherrera.jwtapp&quot;)
@PropertySource(&quot;classpath:database.properties&quot;)
public class AppConfig {

    @Autowired
    Environment environment;

    @Bean
    DataSource dataSource() {
        DriverManagerDataSource driverManagerDataSource = new DriverManagerDataSource();
        driverManagerDataSource.setUrl(environment.getProperty(&quot;url&quot;));
        driverManagerDataSource.setUsername(environment.getProperty(&quot;username&quot;));
        driverManagerDataSource.setPassword(environment.getProperty(&quot;dbpassword&quot;));
        driverManagerDataSource.setDriverClassName(environment.getProperty(&quot;driverClassName&quot;));
        return driverManagerDataSource;
    }

}

</code></pre>

<p><strong><code>SQLiteDialect.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.config;

import java.sql.Types;

import org.hibernate.dialect.Dialect;
import org.hibernate.dialect.function.StandardSQLFunction;
import org.hibernate.dialect.function.SQLFunctionTemplate;
import org.hibernate.dialect.function.VarArgsSQLFunction;
import org.hibernate.type.StandardBasicTypes;

public class SQLiteDialect extends Dialect {
    public SQLiteDialect() {
        super();
        registerColumnType(Types.BIT, &quot;integer&quot;);
        registerColumnType(Types.TINYINT, &quot;tinyint&quot;);
        registerColumnType(Types.SMALLINT, &quot;smallint&quot;);
        registerColumnType(Types.INTEGER, &quot;integer&quot;);
        registerColumnType(Types.BIGINT, &quot;bigint&quot;);
        registerColumnType(Types.FLOAT, &quot;float&quot;);
        registerColumnType(Types.REAL, &quot;real&quot;);
        registerColumnType(Types.DOUBLE, &quot;double&quot;);
        registerColumnType(Types.NUMERIC, &quot;numeric&quot;);
        registerColumnType(Types.DECIMAL, &quot;decimal&quot;);
        registerColumnType(Types.CHAR, &quot;char&quot;);
        registerColumnType(Types.VARCHAR, &quot;varchar&quot;);
        registerColumnType(Types.LONGVARCHAR, &quot;longvarchar&quot;);
        registerColumnType(Types.DATE, &quot;date&quot;);
        registerColumnType(Types.TIME, &quot;time&quot;);
        registerColumnType(Types.TIMESTAMP, &quot;timestamp&quot;);
        registerColumnType(Types.BINARY, &quot;blob&quot;);
        registerColumnType(Types.VARBINARY, &quot;blob&quot;);
        registerColumnType(Types.LONGVARBINARY, &quot;blob&quot;);
        // registerColumnType(Types.NULL, &quot;null&quot;);
        registerColumnType(Types.BLOB, &quot;blob&quot;);
        registerColumnType(Types.CLOB, &quot;clob&quot;);
        registerColumnType(Types.BOOLEAN, &quot;integer&quot;);

        registerFunction(&quot;concat&quot;, new VarArgsSQLFunction(StandardBasicTypes.STRING, &quot;&quot;, &quot;||&quot;, &quot;&quot;));
        registerFunction(&quot;mod&quot;, new SQLFunctionTemplate(StandardBasicTypes.INTEGER, &quot;?1 % ?2&quot;));
        registerFunction(&quot;substr&quot;, new StandardSQLFunction(&quot;substr&quot;, StandardBasicTypes.STRING));
        registerFunction(&quot;substring&quot;, new StandardSQLFunction(&quot;substr&quot;, StandardBasicTypes.STRING));
    }

    public boolean supportsIdentityColumns() {
        return true;
    }

    public boolean hasDataTypeInIdentityColumn() {
        return false; // As specify in NHibernate dialect
    }

    public String getIdentityColumnString() {
        // return &quot;integer primary key autoincrement&quot;;
        return &quot;integer&quot;;
    }

    public String getIdentitySelectString() {
        return &quot;select last_insert_rowid()&quot;;
    }

    public boolean supportsLimit() {
        return true;
    }

    public String getLimitString(String query, boolean hasOffset) {
        return new StringBuffer(query.length() + 20).append(query).append(hasOffset ? &quot; limit ? offset ?&quot; : &quot; limit ?&quot;)
                .toString();
    }

    public boolean bindLimitParametersInReverseOrder() {
        return true;
    }

    public boolean supportsTemporaryTables() {
        return true;
    }

    public String getCreateTemporaryTableString() {
        return &quot;create temporary table if not exists&quot;;
    }

    public boolean dropTemporaryTableAfterUse() {
        return false;
    }

    public boolean supportsCurrentTimestampSelection() {
        return true;
    }

    public boolean isCurrentTimestampSelectStringCallable() {
        return false;
    }

    public String getCurrentTimestampSelectString() {
        return &quot;select current_timestamp&quot;;
    }

    public boolean supportsUnionAll() {
        return true;
    }

    public boolean hasAlterTable() {
        return false; // As specify in NHibernate dialect
    }

    public boolean dropConstraints() {
        return false;
    }

    public String getAddColumnString() {
        return &quot;add column&quot;;
    }

    public String getForUpdateString() {
        return &quot;&quot;;
    }

    public boolean supportsOuterJoinForUpdate() {
        return false;
    }

    public String getDropForeignKeyString() {
        throw new UnsupportedOperationException(&quot;No drop foreign key syntax supported by SQLiteDialect&quot;);
    }

    public String getAddForeignKeyConstraintString(String constraintName, String[] foreignKey, String referencedTable,
            String[] primaryKey, boolean referencesPrimaryKey) {
        throw new UnsupportedOperationException(&quot;No add foreign key syntax supported by SQLiteDialect&quot;);
    }

    public String getAddPrimaryKeyConstraintString(String constraintName) {
        throw new UnsupportedOperationException(&quot;No add primary key syntax supported by SQLiteDialect&quot;);
    }

    public boolean supportsIfExistsBeforeTableName() {
        return true;
    }

    public boolean supportsCascadeDelete() {
        return false;
    }
}

</code></pre>

<h4 id="cllherrerajwtappcontroller"><strong><code>cl.lherrera.jwtapp.controller</code></strong></h4>
<p><strong><code>/jwtapp/src/main/java/cl/lherrera/jwtapp/controller/ControladorAplicacion.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


@RestController
@RequestMapping(value = &quot;/api/v1&quot;)
public class ControladorAplicacion {

    @GetMapping(path = &quot;/isAlive&quot;)
    public String isAlive() {
        return &quot;200&quot;;
    }
}

</code></pre>

<p><strong><code>/jwtapp/src/main/java/cl/lherrera/jwtapp/controller/ControladorIngreso.java</code></strong></p>
<pre><code class="java">/**
 * Luego de crear al usuario, lo accedemos con sus credenciales
 * para obtener un token.
 * 
 * POST: http://localhost:8080/api/v1/iniciarsesion?correo=l.herrera.garnica@gmail.com&amp;password=1234
 * 
 * Sin cuerpo
 * 
 * Respuesta esperada, el token, sin el Bearer.
 * 
 */
package cl.lherrera.jwtapp.controller;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import cl.lherrera.jwtapp.service.ServicioUsuario;

@RestController
@RequestMapping(path = &quot;/api/v1/iniciarsesion&quot;)
public class ControladorIngreso {
    private Logger logger = LoggerFactory.getLogger(ControladorIngreso.class);

    @Autowired
    private ServicioUsuario servicioUsuario;

    @PostMapping(path = {&quot;&quot;, &quot;/&quot;})
    public String iniciarSesion(
            @RequestParam String correo, @RequestParam String password) {
        logger.debug( String.format(&quot;INICIARSESION: ]%s[, ]%s[&quot;, correo, password) );
        return servicioUsuario.iniciarSesion(correo, password);
    }
}

</code></pre>

<p><strong><code>/jwtapp/src/main/java/cl/lherrera/jwtapp/controller/ControladorRegistro.java</code></strong></p>
<pre><code class="java">/**
 * Servicio que registra a un usuario. Se pide que además retorne el token.
 * No es bueno que un método realice dos tareas principales. Pero en esta ocación
 * lo hacemos para obtener el token y no tener que hacer el login. En un sistema
 * productivo, debería solo registrar. Luego, deberíamos iniciar sesión de manera manual
 * 
 * Headers:
 *  Content-Type:application/json
 * POST:
 *  http://localhost:8080/api/v1/registrar
 * BODY-EXAMPLE
 * 
 * &lt;code&gt;
{
    &quot;nombre&quot;: &quot;Luis Herrera&quot;,
    &quot;email&quot;: &quot;l.herrera.garnica@gmail.com&quot;,
    &quot;password&quot;: &quot;1234&quot;,
    &quot;roles&quot;: [&quot;ROLE_ADMINISTRADOR&quot;]
}
&lt;code&gt;
 */
package cl.lherrera.jwtapp.controller;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import cl.lherrera.jwtapp.dto.UsuarioDTO;
import cl.lherrera.jwtapp.service.ServicioUsuario;

// para que no retorne vistas.
@RestController
@RequestMapping(path = &quot;/api/v1/registrar&quot;)
public class ControladorRegistro {
    private Logger logger = LoggerFactory.getLogger(ControladorRegistro.class);

    @Autowired
    ServicioUsuario servicioUsuario;

    @PostMapping(path = { &quot;&quot;, &quot;/&quot; })
    public String registrarUsuaio(@RequestBody UsuarioDTO usuarioDTO) {
        logger.debug(&quot;Registrando al usuario: &quot; + usuarioDTO.toString());
        return servicioUsuario.registraNuevoUsuario(usuarioDTO);
    }

}

</code></pre>

<p><strong><code>/jwtapp/src/main/java/cl/lherrera/jwtapp/controller/ControladorUsuario.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import cl.lherrera.jwtapp.dto.UsuarioDTO;
import cl.lherrera.jwtapp.service.ServicioUsuario;


@RestController
@RequestMapping(&quot;/api/v1/usuarios&quot;)
public class ControladorUsuario {

    @Autowired
    private ServicioUsuario servicioUsuario;

    /**
     * Servicio para listar los usuarios, requiere ser accedido mediante el uso de
     * tokens &lt;code&gt;
     * POST: http://localhost:8080/api/v1/usuarios/
     * 
     * Headers
     * 
     * {
     *     Autorizacion: Bearer ...token que generemos, este parámetro 
     *     lo personalizamos en HEADER_AUTHORIZATION_KEY (JwtToken.java)
     * }
     * &lt;/code&gt;
     */
    @GetMapping(path = { &quot;&quot;, &quot;/&quot; })
    public List&lt;UsuarioDTO&gt; listar() {

        return servicioUsuario.listaDeUsuarios();
    }

}

</code></pre>

<h4 id="cllherrerajwtappdao"><strong><code>cl.lherrera.jwtapp.dao</code></strong></h4>
<p><strong><code>/jwtapp/src/main/java/cl/lherrera/jwtapp/dao/UsuarioDao.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.dao;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import cl.lherrera.jwtapp.model.Usuario;

@Repository
public interface UsuarioDao extends JpaRepository&lt;Usuario, Integer&gt; {
    boolean existsByUsername(String username);
    Optional&lt;Usuario&gt; findByUsername(String username);
}

</code></pre>

<h4 id="cllherrerajwtappdto"><strong><code>cl.lherrera.jwtapp.dto</code></strong></h4>
<pre><code class="java">package cl.lherrera.jwtapp.dto;

import java.util.List;

import cl.lherrera.jwtapp.model.Rol;

public class UsuarioDTO {

    private String nombre;
    private String email;
    private String password;
    private List&lt;Rol&gt; roles;

    public UsuarioDTO() {
    }

    public UsuarioDTO(String nombre, String email, String password, List&lt;Rol&gt; roles) {
        super();
        this.nombre = nombre;
        this.email = email;
        this.password = password;
        this.roles = roles;
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public List&lt;Rol&gt; getRoles() {
        return roles;
    }

    public void setRoles(List&lt;Rol&gt; roles) {
        this.roles = roles;
    }

    @Override
    public String toString() {
        return &quot;UsuarioDTO [nombre=&quot; + nombre + &quot;, email=&quot; + email + &quot;, password=&quot; + password + &quot;, roles=&quot; + roles
                + &quot;]&quot;;
    }

}

</code></pre>

<h4 id="cllherrerajwtappmapper"><strong><code>cl.lherrera.jwtapp.mapper</code></strong></h4>
<p><strong><code>UsuarioMapper.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.mapper;

import java.util.Arrays;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import cl.lherrera.jwtapp.dto.UsuarioDTO;
import cl.lherrera.jwtapp.model.Usuario;

public class UsuarioMapper {
    private static Logger logger = LoggerFactory.getLogger(UsuarioMapper.class);

    private UsuarioMapper() {}

    /**
     * Transforma un Usuario a un UsuarioDTO
     */
    public static UsuarioDTO usuarioADto(Usuario usuario) {
        logger.debug(&quot;Usuario: &quot; + usuario.toString());
        UsuarioDTO dtoUsuario = new UsuarioDTO();
        dtoUsuario.setNombre(usuario.getNombre() + &quot; &quot; + usuario.getApellido());
        dtoUsuario.setEmail(usuario.getUsername());
        dtoUsuario.setRoles(usuario.getRoles());
        dtoUsuario.setPassword(null);

        logger.debug(&quot;Transformado a DTO : &quot; + dtoUsuario.toString());
        return dtoUsuario;
    }

    /**
     * clase privada para separar el nombre y el apellido que viene en un solo campo
     * desde el front se separa si viene con espacio no es muy elegante pero es una
     * solución rápida.
     */
    private static List&lt;String&gt; getNombres(UsuarioDTO dtoUsuario) {
        return Arrays.asList(dtoUsuario.getNombre().split(&quot; &quot;));
    }

    /**
     * Transforma un UsuarioDTO a un Usuario 
     */
    public static Usuario dtoAUsuario(UsuarioDTO dtoUsuario) {
        logger.debug(&quot;UsuarioDTO: &quot; + dtoUsuario.toString());
        List&lt;String&gt; nombres = getNombres(dtoUsuario);

        String nombre = (nombres.size() &gt; 0) ? nombres.get(0) : null;
        String apellido = (nombres.size() &gt; 0) ? nombres.get(1) : null;
        Usuario usuario = new Usuario();
        usuario.setNombre(nombre);
        usuario.setApellido(apellido);
        usuario.setUsername(dtoUsuario.getEmail());
        usuario.setPassword(dtoUsuario.getPassword());
        usuario.setRoles(dtoUsuario.getRoles());

        logger.debug(&quot;Transformado a Usuario: &quot; + usuario.toString());
        return usuario;
    }
}

</code></pre>

<h4 id="cllherrerajwtappmodel"><strong><code>cl.lherrera.jwtapp.model</code></strong></h4>
<p><strong><code>Rol.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.model;

import org.springframework.security.core.GrantedAuthority;

public enum Rol implements GrantedAuthority {
    ROLE_ADMINISTRADOR, ROLE_USUARIO;

    @Override
    public String getAuthority() {
        return name();
    }

}

</code></pre>

<p><strong><code>Usuario.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.model;

import java.util.List;

import javax.persistence.Column;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Usuario {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    Integer id;
    String nombre;
    String apellido;
    @Column(name = &quot;correo&quot;)
    String username;
    @Column(name = &quot;contrasenia&quot;)
    String password;

    @ElementCollection(fetch = FetchType.EAGER)
    List&lt;Rol&gt; roles;

    public Usuario() {}

    public Usuario(Integer id, String nombre, String apellido, String username, String password, List&lt;Rol&gt; roles) {
        super();
        this.id = id;
        this.nombre = nombre;
        this.apellido = apellido;
        this.username = username;
        this.password = password;
        this.roles = roles;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public String getApellido() {
        return apellido;
    }

    public void setApellido(String apellido) {
        this.apellido = apellido;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public List&lt;Rol&gt; getRoles() {
        return roles;
    }

    public void setRoles(List&lt;Rol&gt; roles) {
        this.roles = roles;
    }

    @Override
    public String toString() {
        return &quot;Usuario [id=&quot; + id + &quot;, nombre=&quot; + nombre + &quot;, apellido=&quot; + apellido + &quot;, username=&quot; + username
                + &quot;, password=&quot; + password + &quot;, roles=&quot; + roles + &quot;]&quot;;
    }

}

</code></pre>

<h4 id="cllherrerajwtappsecurity"><strong><code>cl.lherrera.jwtapp.security</code></strong></h4>
<p><strong><code>JwtTokenFilter.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.security;

import java.io.IOException;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import cl.lherrera.jwtapp.apiexception.RestServiceException;


public class JwtTokenFilter extends OncePerRequestFilter {
    private JwtTokenProvider jwtTokenProvider;

    public JwtTokenFilter(JwtTokenProvider jwtTokenProvider) {
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @Override
    protected void doFilterInternal(
            HttpServletRequest request, 
            HttpServletResponse respose, 
            FilterChain filterChain)
            throws ServletException, IOException {

        // extraemos el token del request, este debe ir en el header
        // con el nombre Authentication y en el valor
        String token = jwtTokenProvider.resolveToken(request);

        try {
            // si el token no es nulo y si es válido...
            if (token != null &amp;&amp; jwtTokenProvider.validateToken(token)) {
                // creamos un objeto (new UsernamePasswordAuthenticationToken)
                // ya las credenciales no están disponibles, solamente `userDetails``
                Authentication auth = jwtTokenProvider.getAuthentication(token);
                SecurityContextHolder.getContext().setAuthentication(auth);
            }
        } catch (RestServiceException ex) {

            SecurityContextHolder.clearContext();
            respose.sendError(ex.getHttpStatus().value(), ex.getMessage());
            return;

        }
        filterChain.doFilter(request, respose);
    }
}

</code></pre>

<p><strong><code>JwtTokenFilterConfigurer.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.security;

import org.springframework.security.config.annotation.SecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.DefaultSecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

public class JwtTokenFilterConfigurer extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt; {
    private JwtTokenProvider jwtTokenProvider;

    public JwtTokenFilterConfigurer(JwtTokenProvider jwtTokenProvider) {
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        JwtTokenFilter customFilter = new JwtTokenFilter(jwtTokenProvider);
        http.addFilterBefore(customFilter, UsernamePasswordAuthenticationFilter.class);
    }
}

</code></pre>

<p><strong><code>JwtTokenProvider.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.security;

import java.util.Base64;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import javax.annotation.PostConstruct;
import javax.servlet.http.HttpServletRequest;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import cl.lherrera.jwtapp.apiexception.RestServiceException;
import cl.lherrera.jwtapp.model.Rol;
import cl.lherrera.jwtapp.service.ServicioUsuario;

// dependencia jjwt
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

@Component
public class JwtTokenProvider {
    private Logger logger = LoggerFactory.getLogger(JwtTokenProvider.class);

    private final static String HEADER_AUTHORIZATION_KEY = &quot;Autorizacion&quot;;
    private final static String TOKEN_BEARER_VALUE = &quot;Bearer &quot;;

    // propiedad
    @Value(&quot;${security.jwt.token.secret-key}&quot;)
    private String secretKey;

    // propiedad
    @Value(&quot;${security.jwt.token.expire-length}&quot;)
    private long validityInMilliseconds;

    // servicio Implementado
    @Autowired
    private ServicioUsuario servicioUsuario;

    /**
     * Spring calls methods annotated with @PostConstruct
     * only once, just after the initialization 
     * of bean properties.
     * https://www.baeldung.com/spring-postconstruct-predestroy
     * 
     * Asigna el valor de la clave secreta
     */
    @PostConstruct
    protected void init() {
        secretKey = Base64.getEncoder().encodeToString(secretKey.getBytes());
        logger.debug(&quot;LLave inicializada: &quot; + secretKey);
    }

    public String createToken(String username, List&lt;Rol&gt; roles) {
        Claims claims = Jwts.claims().setSubject(username);

        List&lt;SimpleGrantedAuthority&gt; grats = roles.stream()
                .map(rol -&gt; new SimpleGrantedAuthority(rol.getAuthority()) )
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        claims.put(&quot;auth&quot;, grats);

        // expiración del token
        Date now = new Date();
        Date validity = new Date(now.getTime() + validityInMilliseconds);

        // creación del token
        String token = Jwts.builder()
            .setClaims(claims)
            .setIssuedAt(now)
            .setExpiration(validity)
            .signWith(SignatureAlgorithm.HS256, secretKey)
            .compact(); 

        return token;
    }

    /**
     * A partir del token se obtiene el nombre de usuario y luego, 
     * se obtiene un `UserDetails`, que ya sabemos que es la 
     * entidad que maneja como ususuario de sesión.
     */
    public Authentication getAuthentication(String token) {
        UserDetails userDetails = servicioUsuario.loadUserByUsername(getUsername(token));
        UsernamePasswordAuthenticationToken autenticacion;
        autenticacion = new UsernamePasswordAuthenticationToken(
                userDetails, 
                &quot;&quot;, 
                userDetails.getAuthorities()
        );

        return autenticacion;
    }

    /**
     * En la configuración de seguridad
     * lo que sabe Spring es que el nombre
     * de usuario es el correo. 
     */
    private String getUsername(String token) {
        String userName = Jwts.parser()
                .setSigningKey(secretKey)
                .parseClaimsJws(token)
                .getBody()
                .getSubject();

    return userName;

    }

    /**
     * Quitamos &quot;Bearer &quot; del principio del token
     */
    public String resolveToken(HttpServletRequest req) {
        String tokenReal = null;
        String bearerToken = req.getHeader(HEADER_AUTHORIZATION_KEY);
        logger.debug(&quot;Bearer token: &quot; + bearerToken);
        boolean inicioOk = (bearerToken != null &amp;&amp; bearerToken.startsWith(TOKEN_BEARER_VALUE));
        if (inicioOk) {
            tokenReal = bearerToken.substring(TOKEN_BEARER_VALUE.length());
        }
        return tokenReal;
    }

    /**
     * Si el token logra ser parseado, entonces se asume que es un
     * Token válido. `parseClaimsJws` analiza la llave (no un 
     * token que exista hipoteticamente, la comparación se 
     * realiza entre el token que está en el request
     * y la clave cifrada de esta clase. cifrada
     * justo después de construirse este
     * objeto `INIT`).
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {

            throw new RestServiceException(
                &quot;Expired or invalid JWT token&quot;, 
                HttpStatus.INTERNAL_SERVER_ERROR
            );
        }
    }
}

</code></pre>

<p><strong><code>WebSecurityConfig.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;


@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private JwtTokenProvider jwtTokenProvider;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // sin verificación csrf, inseguro. (Laravel)
        http.csrf().disable();

        // sesión sin estado.
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);

        // Autorización de peticiones.
        http.authorizeRequests()
            // servicios públicos.
            .antMatchers(
                    &quot;/api/v1/isAlive&quot;,
                    &quot;/api/v1/iniciarsesion&quot;,
                    &quot;/api/v1/registrar&quot;).permitAll()
            // todos los demás. servicios, solamente para usuarios autenticados.
            .anyRequest().authenticated();

        // Applies a {@link SecurityConfigurer} to this {@link SecurityBuilder} overriding any
        // {@link SecurityConfigurer} of the exact same class. Note that object hierarchies
        // are not considered.
        // 
        // El filtro personaliizado que creamos en JwtTokenFilterConfigurer, donde
        // validamos el token, y si es válido crea el Authenticate, se aplica acá
        // es un filtro que se concatena a los que ya hemos puesto en este mismo
        // método, se aplica antes que a todos por que JwtTokenFilterConfigurer
        // HttpSecurity.addFilterBefore(customFilter, UsernamePasswordAuthenticationFilter.class);
        // le decimos que el filtro lo realice antes que se ejecute la autenticación con
        // user y password.
        http.apply(new JwtTokenFilterConfigurer(jwtTokenProvider) );
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        // fuerza = 12 (entre 4 y 31)
        return new BCryptPasswordEncoder(12);
    }
}
</code></pre>

<h4 id="cllherrerajwtappservice"><strong><code>cl.lherrera.jwtapp.service</code></strong></h4>
<p><strong><code>ServicioUsuario.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.service;

import java.util.List;

import org.springframework.security.core.userdetails.UserDetailsService;

import cl.lherrera.jwtapp.dto.UsuarioDTO;

/**
 * Al extender UserDetailsService, traemos el método loadUserByUsername, que
 * sobre escribimos en la implementación, podremos ver que a veces se implementa
 * un implements UserDetailsService, pero esto causa confusiones ya que a veces
 * los desarrolladores que no conocen que este método está en
 * UserDetailsService, lo ponen igual acá, en this. y lo sobre escriben en la
 * implementación, funcionando de todas formas por que Spring asume sobre
 * escrito el loadUserByUsername que le pertenece a UserDetailsService y no
 * ServicioUsuario.
 *
 */
public interface ServicioUsuario extends UserDetailsService {

    String iniciarSesion(String correo, String contrasenia);

    List&lt;UsuarioDTO&gt; listaDeUsuarios();

    /**
     * Servicio encargado de registrar un usuario hay que tener en cuenta varias
     * cosas como el dar una buena encriptación a la base de datos.
     */
    String registraNuevoUsuario(UsuarioDTO usuarioDTO);

}

</code></pre>

<p><strong><code>ServicioUsuarioImpl.java</code></strong></p>
<pre><code class="java">package cl.lherrera.jwtapp.service;

import java.util.List;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import cl.lherrera.jwtapp.apiexception.RestServiceException;
import cl.lherrera.jwtapp.dao.UsuarioDao;
import cl.lherrera.jwtapp.dto.UsuarioDTO;
import cl.lherrera.jwtapp.mapper.UsuarioMapper;
import cl.lherrera.jwtapp.model.Usuario;
import cl.lherrera.jwtapp.security.JwtTokenProvider;

@Service
public class ServicioUsuarioImpl implements ServicioUsuario {
    private Logger logger = LoggerFactory.getLogger(ServicioUsuarioImpl.class);

    @Autowired
    UsuarioDao daoUsuario;

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private JwtTokenProvider jwtTokenProvider;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public String iniciarSesion(String correo, String contrasenia) {
        String token = &quot;&quot;;
        logger.debug(&quot;Inicio de la sesión: correo: &quot; + correo + &quot;contraseña: &quot; + contrasenia);
        try {
            // intenta crear la autenticación.
            // si no puede, se envía un AuthenticationException.
            Authentication objetoAutentificacion = new UsernamePasswordAuthenticationToken(correo, contrasenia);
            authenticationManager.authenticate(objetoAutentificacion);
            Usuario usuarioAutenticado = daoUsuario.findByUsername(correo).orElse(null);
            if (usuarioAutenticado != null)
                token = generaToken(usuarioAutenticado);

        } catch (AuthenticationException e) {
            throw new RestServiceException(&quot;username o password invalido&quot;, HttpStatus.UNPROCESSABLE_ENTITY);
        }

        return token;
    }

    private String generaToken(Usuario usuario) {
        String token = jwtTokenProvider.createToken(usuario.getUsername(), usuario.getRoles());
        logger.debug(&quot;Token generado: ...&quot; + token.substring(token.length() - 5));

        return token;
    }

    @Override
    public List&lt;UsuarioDTO&gt; listaDeUsuarios() {

        List&lt;UsuarioDTO&gt; usuarios = daoUsuario.findAll().stream()
                // cada uno de los usuarios pasando a un DTO
                .map(usuario -&gt; UsuarioMapper.usuarioADto(usuario)).collect(Collectors.toList());

        logger.debug(&quot;Lista de usuarioDTO: &quot; + usuarios.toString());
        return usuarios;
    }

    @Override
    public String registraNuevoUsuario(UsuarioDTO dtoUsuario) {
        String token = null;
        // verificar si el usuario existe para no ingresarlo otra vez
        Usuario usuario = daoUsuario.findByUsername(dtoUsuario.getEmail()).orElse(null);

        if (usuario == null) {
            String constraseniaEnDuro = dtoUsuario.getPassword();
            String constraseniaEncriptada = passwordEncoder.encode(constraseniaEnDuro);
            dtoUsuario.setPassword(constraseniaEncriptada);
            // guardamos el usuario convertido desde un DTO
            usuario = UsuarioMapper.dtoAUsuario(dtoUsuario);

            logger.debug(&quot;Registrando nuevo usuario: &quot; + usuario.toString());
            daoUsuario.save(usuario);

            logger.debug(&quot;Usuario nuevo registrado: &quot; + usuario.toString());
            logger.debug(&quot;Generando token... &quot;);

            token = this.generaToken(usuario);
        }

        return token;
    }

    /**
     * Se implementa desde UserDetailsService, interface que extiende 
     * ServicioUsuario.
     * 
     * Se supone que se debe cargar el nombre de usuario y en este caso es 
     * correo, es por que se exige un valor de nombre de usuario, que puede ser
     * por ejemplo: rut, correo, nombre de usuario, tag name, etc. El cómo se maneje
     * dependerá de nuestra implementación.
     * 
     * Construye un `UserDetails` estático, con la información que se le
     * proporcione. En este caso, el nombre de usuario que venía como argumento y la
     * contraseña que está en la base de datos. Este proceso es implementado ya que
     * este único método, posee acceso a la contraseña del usuario. La técnica usada
     * es que cada método retorna un `UserBuilder`, hasta llegar a `build()`, es
     * cuando finalmente es convertido en un `UserDetail`.
     * 
     **/
    @Override
    public UserDetails loadUserByUsername(String correo) throws UsernameNotFoundException {
        final Usuario user = daoUsuario.findByUsername(correo).orElse(null);
        if (user == null) {
            throw new UsernameNotFoundException(&quot;Usuario '&quot; + correo + &quot;' no encontrado&quot;);
        }
        return org.springframework.security.core.userdetails.User//
                .withUsername(correo).password(user.getPassword()).authorities(user.getRoles()).accountExpired(false)
                .accountLocked(false).credentialsExpired(false).disabled(false).build();
    }

}

</code></pre>

<h3 id="jwtappsrcmainresources"><strong><code>/jwtapp/src/main/resources</code></strong></h3>
<h4 id="applicationproperties"><strong><code>application.properties</code></strong></h4>
<pre><code class="conf">
spring.jpa.generate-ddl=true
spring.jpa.database-platform=cl.lherrera.jwtapp.config.SQLiteDialect
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.properties.hibernate.format_sql=true

# Configuración para el token.
security.jwt.token.secret-key=DLatam-SecretKey
security.jwt.token.expire-length=3600000

# Para mostrar el log de debug
# esto no se mostraría en producción
logging.level.org.springframework.web=DEBUG
#logging.level.root=DEBU
logging.level.cl.lherrera.jwtapp=DEBUG
logging.file.name=logs

</code></pre>

<h4 id="databaseproperties"><strong><code>database.properties</code></strong></h4>
<pre><code class="conf">driverClassName=org.sqlite.JDBC
url=jdbc:sqlite:baseDeDatos.db
username=jpaspring
password=sa

</code></pre>

<h3 id="jwtapppomxml"><strong><code>/jwtapp/pom.xml</code></strong></h3>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.7.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;cl.lherrera&lt;/groupId&gt;
    &lt;artifactId&gt;jwtapp&lt;/artifactId&gt;
    &lt;version&gt;20.0.0&lt;/version&gt;
    &lt;name&gt;jwtapp&lt;/name&gt;
    &lt;description&gt;aplicación básica de JWT&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!-- JWT - SUPPORT --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
            &lt;version&gt;0.9.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- JWT - SUPPORT # --&gt;
        &lt;!-- SQLITE - SUPPORT --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.xerial&lt;/groupId&gt;
            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- SQLITE - SUPPORT #--&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;

</code></pre>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../../../assets/javascripts/vendor.a0c4167b.min.js"></script>
      <script src="../../../../assets/javascripts/bundle.fb26dd1d.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../../../..",
          features: [],
          search: Object.assign({
            worker: "../../../../assets/javascripts/worker/search.37585f48.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>