


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-5.1.6">
    
    
      
        <title>Lectura002 002 - Java Full Stack Docs</title>
      
    
    
      <link rel="stylesheet" href="../../../../assets/stylesheets/main.4b9ffd7b.min.css">
      
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    <body dir="ltr">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#unidad-622-rest" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../../../.." title="Java Full Stack Docs" class="md-header-nav__button md-logo" aria-label="Java Full Stack Docs">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            Java Full Stack Docs
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Lectura002 002
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../.." title="Java Full Stack Docs" class="md-nav__button md-logo" aria-label="Java Full Stack Docs">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Java Full Stack Docs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../../../../ejercicios/repaso/teoria/poo/herencia/" title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#6221-servicios" class="md-nav__link">
    6.2.2.1 Servicios
  </a>
  
    <nav class="md-nav" aria-label="6.2.2.1 Servicios">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#servicio-registrar-usuarios" class="md-nav__link">
    Servicio: Registrar usuarios
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#servicio-consultar-la-lista-de-usuarios" class="md-nav__link">
    Servicio: Consultar la lista de usuarios
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#servicio-iniciar-sesion" class="md-nav__link">
    Servicio Iniciar sesión
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6222-archivos-modificados" class="md-nav__link">
    6.2.2.2 Archivos modificados
  </a>
  
    <nav class="md-nav" aria-label="6.2.2.2 Archivos modificados">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#produce-restsrcmainresources" class="md-nav__link">
    /produce-rest/src/main/resources
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherreraprmodeloentity" class="md-nav__link">
    cl.lherrera.pr.modelo.entity
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherreraprmodelorepository" class="md-nav__link">
    cl.lherrera.pr.modelo.repository
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherreraprsecurity" class="md-nav__link">
    cl.lherrera.pr.security
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherreraprutils" class="md-nav__link">
    cl.lherrera.pr.utils
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherreraprservicio" class="md-nav__link">
    cl.lherrera.pr.servicio
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherreraprexception" class="md-nav__link">
    cl.lherrera.pr.exception
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherreraprdto" class="md-nav__link">
    cl.lherrera.pr.dto
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cllherreraprcontroller" class="md-nav__link">
    cl.lherrera.pr.controller
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#produce-restpomxml" class="md-nav__link">
    /produce-rest/pom.xml
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#todo" class="md-nav__link">
    TODO
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  
                
                
                <blockquote>
<h1 id="unidad-622-rest">Unidad 6.2.2 - Rest</h1>
<blockquote>
<ul>
<li>Aplicación de seguridad basado en <code>Java Web Token (JWT)</code> al ejemplo anterior.</li>
<li>La seguridad mediante <code>JWT</code> se realiza mediante la aplicación de dos patrones, <code>Adapter</code> y <code>Proxy</code>, Cada medida de seguridad, se adapta para poder ser incluida en todas aquellas clases que implementan <code>SecurityConfigurer&lt;A, B&gt;</code>. </li>
<li>El filtro se realiza con el patrón <code>PROXY</code> que, mediante una serie de reglas, habilita o deshabilita los accesos a ciertas solicitudes o <code>requests</code>.</li>
</ul>
</blockquote>
</blockquote>
<hr />
<h2 id="6221-servicios"><strong>6.2.2.1 Servicios</strong></h2>
<h3 id="servicio-registrar-usuarios"><strong>Servicio: Registrar usuarios</strong></h3>
<p>registra un usuario dado un cuerpo, se obtiene como respuesta exitosa, un <code>token</code>, recordar que no se envía sin el <strong><code>"Bearer "</code></strong> ya que el <code>resolveToken</code> lo pide así, esto es una especie de otra palabra secreta o dato único que manejan pocas personas, para aumentar la seguridad.</p>
<p>URL: <code>http://localhost:8080/api/v1/users/signup</code></p>
<p>TYPE: POST</p>
<p>BODY</p>
<pre><code class="json">{
    &quot;name&quot;: &quot;Luis Herrera&quot;,
    &quot;username&quot;: &quot;lherrera&quot;,
    &quot;email&quot;: &quot;l.herrera.garnica@gmail.com&quot;,
    &quot;password&quot;: &quot;1234&quot;,
    &quot;roles&quot;: [&quot;ROLE_ADMIN&quot;, &quot;ROLE_CLIENT&quot;]
}
</code></pre>

<p>Respuesta del momento, esta cambia en cada solicitud:</p>
<pre><code>eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJsaGVycmVyYSIsImF1dGgiOlt7ImF1dGhvcml0eSI6IlJPTEVfQURNSU4ifSx7ImF1dGhvcml0eSI6IlJPTEVfQ0xJRU5UIn1dLCJpYXQiOjE1ODk1MDg2ODQsImV4cCI6MTU4OTUxMjI4NH0.m9mLeRsytrq3d2Ax7_XpNFyOMxO0l4lv3s9PmUkEWM8
</code></pre>

<h3 id="servicio-consultar-la-lista-de-usuarios"><strong>Servicio: Consultar la lista de usuarios</strong></h3>
<p>Lista a los usuarios si es que estamos registrados.</p>
<p>URL: <code>http://localhost:8080/api/v1/users/</code></p>
<p>TYPE: GET</p>
<p>HEADER</p>
<p>Se adiciona un campo <code>Authorization</code> que contiene el token entregado por el sistema, antecedido por <code>"bearer "</code>.</p>
<pre><code class="python">{
    Authorization : Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJsaGVycmVyYSIsImF1dGgiOlt7ImF1dGhvcml0eSI6IlJPTEVfQURNSU4ifSx7ImF1dGhvcml0eSI6IlJPTEVfQ0xJRU5UIn1dLCJpYXQiOjE1ODk1MDg2ODQsImV4cCI6MTU4OTUxMjI4NH0.m9mLeRsytrq3d2Ax7_XpNFyOMxO0l4lv3s9PmUkEWM8
}
</code></pre>

<p>Si ejecutamos la solicitud sin el campo <code>Autorization</code> Nombre que le damos en la configuración de seguridad para analizar el token, es decir, si hacemos una solicitud, sin estar registrados en el sistema nos arroja el siguiente error:</p>
<pre><code class="json">{
    &quot;timestamp&quot;: &quot;2020-05-15T02:17:59.199+0000&quot;,
    &quot;status&quot;: 403,
    &quot;error&quot;: &quot;Forbidden&quot;,
    &quot;message&quot;: &quot;Access Denied&quot;,
    &quot;path&quot;: &quot;/api/v1/users/&quot;
}
</code></pre>

<p>En caso contrario:</p>
<p>Vemos que la contraseña no es indicada, esto lo hacemos en la utilidad que convierte Usuarios a Usuarios DTO, en este cambio aplicamos la regla de negocio por seguridad, y <code>seteamos</code> el objeto <code>parseado</code> a objeto DTO a <code>null</code>. <code>public static UserDTO toDTO(User user) {</code></p>
<pre><code class="json">[
    {
        &quot;id&quot;: 1,
        &quot;name&quot;: &quot;Luis Herrera&quot;,
        &quot;username&quot;: &quot;lherrera&quot;,
        &quot;email&quot;: &quot;l.herrera.garnica@gmail.com&quot;,
        &quot;password&quot;: null,
        &quot;roles&quot;: [
            &quot;ROLE_ADMIN&quot;,
            &quot;ROLE_CLIENT&quot;
        ]
    }
]
</code></pre>

<h3 id="servicio-iniciar-sesion"><strong>Servicio Iniciar sesión</strong></h3>
<p>URL: <code>http://localhost:8080/api/v1/users/signin?username=lherrera&amp;password=1234</code></p>
<p>TYPE: POST, aunque tenga parámetros en la <code>url</code>, este concepto no se limita a esta descripción. De esta forma, nos aseguramos aunque las credenciales van en la <code>url</code>, no se verá por que la encapsula el <code>POST</code>.</p>
<p>Si las credenciales están correctas, obtendremos el token. </p>
<p>En caso contrario:</p>
<pre><code class="json">{
    &quot;timestamp&quot;: &quot;2020-05-15T02:34:05.917+0000&quot;,
    &quot;status&quot;: 500,
    &quot;error&quot;: &quot;Internal Server Error&quot;,
    &quot;message&quot;: &quot;username o password invalido&quot;,
    &quot;path&quot;: &quot;/api/v1/users/signin&quot;
}
</code></pre>

<hr />
<h2 id="6222-archivos-modificados"><strong>6.2.2.2 Archivos modificados</strong></h2>
<h3 id="produce-restsrcmainresources"><strong><code>/produce-rest/src/main/resources</code></strong></h3>
<p><strong><code>/application.properties</code></strong></p>
<p>En las propiedades, irán los valores que utilizará la clase proveedora del token. 3.600.000 mili segundos, equivalen a una hora, es decir que el proveedor del token, debe considerar válido un token que haya generado hace máximo, una hora.</p>
<pre><code class="conf">spring.jpa.generate-ddl=true
spring.jpa.database-platform=cl.lherrera.pr.SQLiteDialect
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.properties.hibernate.format_sql=true

# Configuración para el token.
security.jwt.token.secret-key=DLatam-SecretKey
security.jwt.token.expire-length=3600000

</code></pre>

<h3 id="cllherreraprmodeloentity"><strong><code>cl.lherrera.pr.modelo.entity</code></strong></h3>
<p>Actualizamos las entidades del modelo, para poder cumplir con características de configuración de seguridad de <code>Spring Security</code>.</p>
<p>Los modelos necesarios para trabajar con las credenciales. De <code>GrantedAuthority</code> implementamos el método <code>getAuthority</code> que retorna el nombre del rol que indicamos en esta clase con los roles. Hacer esto es necesario para usar <code>JWT</code>.</p>
<p><strong><code>/produce-rest/src/main/java/cl/lherrera/pr/modelo/entity/Role.java</code></strong></p>
<p>El modelo debe implementar <code>GrantedAuthority</code>, cuando se usa una clase <code>Enum</code>, listamos los nombres iniciando <code>ROLE_</code>, seguido por el nombre del rol. En el ejemplo son <code>ROLE_ADMIN</code> y <code>ROLE_CLIENT</code>. Posee un método <code>getAuthority()</code>, el que debe ser implementado. Esto se realiza para que la implementación de la seguridad identifique el rol. Es decir, <code>Spring security</code>, cuando necesite saber el rol o los roles que posee un usuario, utilizará la información entregada por <code>gerAuthority()</code>. de una clase que implemente o posea la forma de <code>GrantedAuthority</code>.</p>
<p>La siguiente es una de las formas en que se puede representar el rol en una aplicación. Esto es utilizando un <code>Enum Class</code>, suficiente cuando nuestros roles no sean muchos, sin más base, que la de poder aceptar mirarlos como atributos en una clase y que no sangren los ojos.</p>
<p>Otra técnica es la utilización de una tabla en la base de datos que contenga la información de los roles. Esto es útil para cuando la cantidad de roles que posee la aplicación, demande una mayor cantidad de roles, como lo sería por ejemplo en una entidad educacional, donde hay profesores, estudiantes, directores, sub directores, etc. Si tenemos una gran aplicación central, requeriría aplicar una tabla de roles; pero este no es el caso. Es por esto que se aplica la técnica de la clase <code>Enum</code>, y lo simplificamos además de ahorrarnos la implementación de un <code>many to many</code>, que no tiene mucho que ver con el negocio más allá del contenido de las credenciales, donde solamente sea legible un nombre de usuario y una encriptada contraseña.</p>
<p>La información que posee la capa de seguridad, no cumplen otra función más que la de utilizar técnicas complejas, para mantener identificado el origen que está solicitando información para luego entregarla al mismo punto. No garantiza que el transporte no sea interceptado por terceros, es por eso que la contraseña es enviada encriptada. De esta forma si esta información llega a ser interceptada no puede ser utilizada directamente sin pasar por los algoritmos que están en nuestra aplicación. </p>
<p>Si la información es interceptada y utilizada, el algoritmo interno antes de corroborar con lo que se ingresa lo codifica, no lo compara directamente, por lo que la información que se interceptó, incluso la que está en la base de datos, no se puede utilizar directamente.</p>
<p>Estas implementaciones no deben poder ser <code>decodificadas</code>, solamente <code>codificadas</code> o no serían seguras, el valor siempre debe ser comparado con su valor ya codificado.</p>
<p>Para que la información viaje con una capa adicional de seguridad con todos los datos codificados, esta se debe usar <code>ssl</code>, pero eso forma parte de configuraciones del servidor.</p>
<pre><code class="java">package cl.lherrera.pr.modelo.entity;

import org.springframework.security.core.GrantedAuthority;

public enum Role implements GrantedAuthority {
    ROLE_ADMIN, ROLE_CLIENT;

    @Override
    public String getAuthority() {
        return name();
    }
}

</code></pre>

<p><strong><code>/produce-rest/src/main/java/cl/lherrera/pr/modelo/entity/User.java</code></strong></p>
<p><code>ElementCollection</code> permite un acceso a <code>getAuthority()</code> de forma funcional. <code>usuarioIntentandoIngresar.roles... por cada uno... verificar rol</code>. Si usamos una tabla en la base de datos, esto debe tratarse con un <code>manyToMany</code>; pero dado el caso de la <code>Enum Class</code>, es suficiente con anotar la lista de roles con <code>@ElementCollection</code>.</p>
<p><code>fetch = FetchType.EAGER</code>. Hay dos formas de traer(<code>Fetch</code>) datos, una es la forma ansiosa (<code>EAGER</code>), y la forma perezosa (<code>LAZY</code>). En la forma ansiosa, se trae toda la información de los roles que posee el usuario, que en este caso tenemos dos roles, por lo que las peticiones en partes pequeñas bajo demanda (como tener un millón de registros, no podemos tener todo eso en una sola consulta, el estilo <code>LAZY</code> lo soluciona, implementando técnicas que esperan el momento justo en que se necesita el dato para traerlo, requiere para eso, indudablemente mayor capacidad de procesamiento para estas tareas. Es por esta razón que el uso de <code>LAZY</code> debe estar justificado).</p>
<pre><code class="java">package cl.lherrera.pr.modelo.entity;

import java.util.List;

import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class User {

    @ElementCollection(fetch = FetchType.EAGER)
    private List&lt;Role&gt; roles;

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    private String username; // este es el nombre por defecto
    private String email;
    private String password;

    public User(Long id, String name, String username, String email, String password) {
        super();
        this.id = id;
        this.name = name;
        this.username = username;
        this.email = email;
        this.password = password;
    }

    public User() {
    }

    public List&lt;Role&gt; getRoles() {
        return roles;
    }

    public void setRoles(List&lt;Role&gt; roles) {
        this.roles = roles;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

}

</code></pre>

<h3 id="cllherreraprmodelorepository"><strong><code>cl.lherrera.pr.modelo.repository</code></strong></h3>
<p>Se adicionan métodos necesarios para la implementación de seguridad.</p>
<p><strong><code>/produce-rest/src/main/java/cl/lherrera/pr/modelo/repository/UserRepository.java</code></strong></p>
<pre><code class="java">package cl.lherrera.pr.modelo.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import cl.lherrera.pr.modelo.entity.User;

public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    // necesario para la autenticación
    boolean existsByUsername(String username);

    User findByUsername(String username);
}

</code></pre>

<h3 id="cllherreraprsecurity"><strong><code>cl.lherrera.pr.security</code></strong></h3>
<p>Las clases que deben ser implementadas para la gestión de las credenciales, son dos clases principales:</p>
<ul>
<li><code>JwtTokenFilterConfigurer</code>: Para la gestión del token.</li>
<li><code>WebSecurityConfig</code>: Para la gestión de los accesos a los servicios que expone la aplicación vía web, que en nuestro caso, la aplicación es un servicio web.</li>
</ul>
<p>La técnica consiste en que <code>JwtTokenFilterConfigurer</code>, con el apoyo de sus clases, introduzca un filtro, que cree al usuario justo antes que se accione la validación de usuario autenticado.</p>
<p>Es decir, crea al usuario autenticado, antes que se valide, así, existirá será validado y reconocido. </p>
<p>Luego esta configuración será aplicada en <code>WebSecurityConfig</code>. De esta manera, <strong>la seguridad web</strong>, dispondrá de la técnica de autenticación mediante el uso de token, sin tener que depender del registro normal de acceso al sistema, la denominada autenticación basada en formularios, <strong>aunque en el sistema front, exista un formulario la validación será realizada por el uso de un token.</strong></p>
<p><strong><code>/produce-rest/src/main/java/cl/lherrera/pr/security/JwtTokenProvider.java</code></strong></p>
<p>Su misión es:</p>
<p>No posee constructor, se ejecuta el método <code>init()</code>, justo después de ser inyectado. Consume en esos momentos, los valores de llave y duración que están en las propiedades del proyecto.</p>
<ul>
<li>Crear un token, con una durabilidad suficiente para una sesión.</li>
<li>Obtener la información del objeto <code>Authentication</code> que se ha creado con un token ya creado. Esto para tener los datos del usuario registrado, así poder ocupar estos datos según lo necesitemos.</li>
<li>Validar si un token dado, es válido o si es inválido(por ejemplo, que expiró).</li>
</ul>
<p>Nuestro proveedor de <code>token</code>, no implementa ninguna interfaz y está marcada como un <code>@Component</code>, por que <code>Spring</code> lo inyectará en <code>WebSecurityConfig</code>. Para poder aplicar el inicio de sesión mediante el uso de un <code>token</code>, en <code>WebSecurityConfig</code>, se inyecta <code>JwtTokenProvider</code>, cuando comienza la creación de la configuración para la web, y cuando se se finaliza la disposición de, qué peticiones están habilitadas y para quieres. Se aplica la autenticación por <code>token</code></p>
<p>Los valores se inicializan en el <code>ini()</code>, y este se ejecuta con la anotación <code>@PostConstruct</code>.</p>
<pre><code class="java">package cl.lherrera.pr.security;

import java.util.Base64;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import javax.annotation.PostConstruct;
import javax.servlet.http.HttpServletRequest;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import cl.lherrera.pr.exception.RestServiceException;
import cl.lherrera.pr.modelo.entity.Role;
import cl.lherrera.pr.servicio.UserService;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

@Component
public class JwtTokenProvider {
    private Logger logger = LoggerFactory.getLogger(JwtTokenProvider.class);

    // propiedad
    @Value(&quot;${security.jwt.token.secret-key}&quot;)
    private String secretKey;

    // propiedad
    @Value(&quot;${security.jwt.token.expire-length}&quot;)
    private long validityInMilliseconds;

    // servicio Implementado
    @Autowired
    private UserService userService;

    /**
     * Spring calls methods annotated with @PostConstruct
     * only once, just after the initialization 
     * of bean properties.
     * https://www.baeldung.com/spring-postconstruct-predestroy
     * 
     * Asigna el valor de la clave secreta
     */
    @PostConstruct
    protected void init() {
        secretKey = Base64.getEncoder().encodeToString(secretKey.getBytes());
        logger.debug(&quot;LLave inicializada: &quot; + secretKey);
    }

    public String createToken(String username, List&lt;Role&gt; roles) {
        Claims claims = Jwts.claims().setSubject(username);

        List&lt;SimpleGrantedAuthority&gt; grats = roles.stream()
                .map(rol -&gt; new SimpleGrantedAuthority(rol.getAuthority()) )
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        claims.put(&quot;auth&quot;, grats);

        // expiración del token
        Date now = new Date();
        Date validity = new Date(now.getTime() + validityInMilliseconds);

        // creación del token
        String token = Jwts.builder()
            .setClaims(claims)
            .setIssuedAt(now)
            .setExpiration(validity)
            .signWith(SignatureAlgorithm.HS256, secretKey)
            .compact(); 

        return token;
    }

    /**
     * A partir del token se obtiene el nombre de usuario y luego, 
     * se obtiene un `UserDetails`, que ya sabemos que es la 
     * entidad que maneja como ususuario de sesión.
     */
    public Authentication getAuthentication(String token) {
        UserDetails userDetails = userService.loadUserByUsername(getUsername(token));
        UsernamePasswordAuthenticationToken autenticacion;
        autenticacion = new UsernamePasswordAuthenticationToken(
                userDetails, 
                &quot;&quot;, 
                userDetails.getAuthorities()
        );

        return autenticacion;
    }

    private String getUsername(String token) {
        String userName = Jwts.parser()
                .setSigningKey(secretKey)
                .parseClaimsJws(token)
                .getBody()
                .getSubject();

    return userName;

    }

    /**
     * Quitamos &quot;Bearer &quot; del principio del token
     * esto es un acuerdo entre ambas partes con un encabezado
     * especial si es que así se acuerda, esa referencia
     * será tratada en este método.
     */
    public String resolveToken(HttpServletRequest req) {
        String bearerToken = req.getHeader(&quot;Authorization&quot;);
        if (bearerToken != null &amp;&amp; bearerToken.startsWith(&quot;Bearer &quot;)) {
            return bearerToken.substring(7);
        }
        return null;
    }

    /**
     * Si el token logra ser parseado, entonces se asume que es un
     * Token válido. `parseClaimsJws` analiza la llave (no un 
     * token que exista hipoteticamente, la comparación se 
     * realiza entre el token que está en el request
     * y la clave cifrada de esta clase. cifrada
     * justo después de construirse este
     * objeto `INIT`).
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {

            throw new RestServiceException(
                &quot;Expired or invalid JWT token&quot;, 
                HttpStatus.INTERNAL_SERVER_ERROR
            );
        }
    }
}

</code></pre>

<p><strong><code>/produce-rest/src/main/java/cl/lherrera/pr/security/JwtTokenFilter.java</code></strong></p>
<p>Implementa <code>OncePerRequestFilter</code>, esto significa que sobre escribiendo el método <code>doFilterInternal</code>, por cada una de las peticiones, el <code>request</code> será analizado, y se confirmará su validez o no.</p>
<pre><code class="java">package cl.lherrera.pr.security;

import java.io.IOException;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import cl.lherrera.pr.exception.RestServiceException;

public class JwtTokenFilter extends OncePerRequestFilter {
    private JwtTokenProvider jwtTokenProvider;

    public JwtTokenFilter(JwtTokenProvider jwtTokenProvider) {
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @Override
    protected void doFilterInternal(
            HttpServletRequest request, 
            HttpServletResponse respose, 
            FilterChain filterChain)
            throws ServletException, IOException {

        // extraemos el token del request, este debe ir en el header
        // con el nombre Authentication y en el valor
        String token = jwtTokenProvider.resolveToken(request);

        try {
            // si el token no es nulo y si es válido...
            if (token != null &amp;&amp; jwtTokenProvider.validateToken(token)) {
                // creamos un objeto (new UsernamePasswordAuthenticationToken)
                // ya las credenciales no están disponibles, solamente `userDetails``
                Authentication auth = jwtTokenProvider.getAuthentication(token);
                SecurityContextHolder.getContext().setAuthentication(auth);
            }
        } catch (RestServiceException ex) {

            SecurityContextHolder.clearContext();
            respose.sendError(ex.getHttpStatus().value(), ex.getMessage());
            return;

        }
        filterChain.doFilter(request, respose);
    }
}

</code></pre>

<p><strong><code>/produce-rest/src/main/java/cl/lherrera/pr/security/JwtTokenFilterConfigurer.java</code></strong></p>
<p>Configuración de filtro antes que se ejecute <code>UsernamePasswordAuthenticationFilter</code>, es una de las implementaciones con adaptador de la interfaz <code>SecurityConfigurer&lt;O, B&gt;</code>, esta configuración, es aplicada luego en <code>WebSecurityConfig</code>, que también es una implementación con con adaptador de <code>SecurityConfigurer&lt;O, B&gt;</code>.</p>
<pre><code class="java">package cl.lherrera.pr.security;

import org.springframework.security.config.annotation.SecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.DefaultSecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

public class JwtTokenFilterConfigurer extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt; {
    private JwtTokenProvider jwtTokenProvider;

    public JwtTokenFilterConfigurer(JwtTokenProvider jwtTokenProvider) {
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        JwtTokenFilter customFilter = new JwtTokenFilter(jwtTokenProvider);
        http.addFilterBefore(customFilter, UsernamePasswordAuthenticationFilter.class);
    }
}

</code></pre>

<p><strong><code>/produce-rest/src/main/java/cl/lherrera/pr/security/WebSecurityConfig.java</code></strong></p>
<p>La verdadera configuración de seguridad está acá. El filtro, es decir, la implementación que hace la verificación si se crea una sesión o no, es <code>JwtTokenFilterConfigurer</code>, que se apoya en clases que crean el token, que lo validan, así <code>JwtTokenFilterConfigurer</code> según estime que se cumple o no, crea la sesión o no. Para que esta configuración sea aplicada, debe ser inyectada acá.</p>
<pre><code class="java">package cl.lherrera.pr.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private JwtTokenProvider jwtTokenProvider;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // sin verificación csrf, inseguro. (Laravel)
        http.csrf().disable();

        // sesión sin estado.
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);

        // Autorización de peticiones
        http.authorizeRequests()
            // para los paths -&gt; autorizar todo
            .antMatchers(&quot;/api/v1/users/signin&quot;).permitAll()
            // para los paths -&gt; autorizar todo
            .antMatchers(&quot;/api/v1/users/signup&quot;).permitAll()
            // para todo lo demás, acceso solamente con
            // autentificación.
            .anyRequest().authenticated();

        // en caso que ocurra una excepción de págiina
        // denegada por error de credenciales
        // personalizamos el servicio a ejecutar.
        // que en este caso nos lleva a la 
        // web de login.
        http.exceptionHandling().accessDeniedPage(&quot;/login&quot;);

        // Applies a {@link SecurityConfigurer} to this {@link SecurityBuilder} overriding any
        // {@link SecurityConfigurer} of the exact same class. Note that object hierarchies
        // are not considered.
        // 
        // 
        // El filtro personaliizado que creamos en JwtTokenFilterConfigurer, donde
        // validamos el token, y si es válido crea el Authenticate, se aplica acá
        // es un filtro que se concatena a los que ya hemos puesto en este mismo
        // método, se aplica antes que a todos por que JwtTokenFilterConfigurer
        // HttpSecurity.addFilterBefore(customFilter, UsernamePasswordAuthenticationFilter.class);
        // le decimos que el filtro lo realice antes que se ejecute la autenticación con
        // user y password.
        http.apply(new JwtTokenFilterConfigurer(jwtTokenProvider) );
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        // fuerza = 12 (entre 4 y 31)
        return new BCryptPasswordEncoder(12);
    }
}
</code></pre>

<h3 id="cllherreraprutils"><code>cl.lherrera.pr.utils</code></h3>
<p>Esta clase es solamente adaptada para poder recibir los cambios de la entidad. Es decir que se cambia el alias, por un <code>userName</code>.</p>
<p><strong><code>/produce-rest/src/main/java/cl/lherrera/pr/utils/DTOMapper.java</code></strong></p>
<pre><code class="java">package cl.lherrera.pr.utils;

import cl.lherrera.pr.dto.UserDTO;
import cl.lherrera.pr.modelo.entity.User;

public class DTOMapper {
    private DTOMapper() {
    }

    private static void toEntity(UserDTO userDTO, User user) {
        user.setId(userDTO.getId());
        user.setName(userDTO.getName());
        user.setUsername(userDTO.getUsername());
        user.setEmail(userDTO.getEmail());
        user.setPassword(userDTO.getPassword());
        user.setRoles(userDTO.getRoles());
    }

    public static User toEntity(UserDTO userDTO) {
        User user = new User();
        toEntity(userDTO, user);
        return user;
    }

    public static UserDTO toDTO(User user) {
        UserDTO userDTO = new UserDTO();
        userDTO.setId(user.getId());
        userDTO.setName(user.getName());
        userDTO.setUsername(user.getUsername());
        userDTO.setEmail(user.getEmail());
        userDTO.setPassword(null);
        userDTO.setRoles(user.getRoles());
        return userDTO;
    }
}

</code></pre>

<h3 id="cllherreraprservicio"><code>cl.lherrera.pr.servicio</code></h3>
<p>Los servicios cuentan con más intervenciones</p>
<p><strong><code>/produce-rest/src/main/java/cl/lherrera/pr/servicio/UserService.java</code></strong></p>
<p>Se adicionan métodos que serán implementados, dado que actualizamos la entidad para que tenga las exigencias de un nombre de usuario y una contraseña, configurados en <code>WebSecurityConfig</code>. Podemos personalizar el nombre de los campos a verificar, pero en este caso se utilizan los que vienen por defecto, como lo son <code>username</code>, <code>password</code>.</p>
<pre><code class="java">package cl.lherrera.pr.servicio;

import java.util.List;

import org.springframework.security.core.userdetails.UserDetails;

import cl.lherrera.pr.dto.UserDTO;

public interface UserService {

    void actualizar(UserDTO user);

    List&lt;UserDTO&gt; encontrarTodos();

    UserDTO encontrarPorId(Long id);

    void eliminar(UserDTO user);

    // usados para las credenciales.
    String signin(String username, String password);

    // nuestro nuevo ingresar
    String signup(UserDTO user);

    UserDetails loadUserByUsername(String username);

}

</code></pre>

<p><strong><code>/produce-rest/src/main/java/cl/lherrera/pr/servicio/UserServiceImp.java</code></strong></p>
<p>La implementación del servicio de registro e ingreso al sistema, son las que destacan de todas las modificaciones realizadas, ya que estas producen el token.</p>
<pre><code class="java">package cl.lherrera.pr.servicio;

import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import cl.lherrera.pr.dto.UserDTO;
import cl.lherrera.pr.modelo.entity.User;
import cl.lherrera.pr.modelo.repository.UserRepository;
import cl.lherrera.pr.security.JwtTokenProvider;
import cl.lherrera.pr.utils.DTOMapper;

import cl.lherrera.pr.exception.RestServiceException;

@Service
public class UserServiceImp implements UserService, UserDetailsService {

    @Autowired
    UserRepository repoUsuario;

    // sección de seguridad
    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private JwtTokenProvider jwtTokenProvider;

    @Autowired
    private AuthenticationManager authenticationManager;
    // sección de seguridad #

    @Override
    public void actualizar(UserDTO user) {
        repoUsuario.save(DTOMapper.toEntity(user));
    }

    @Override
    public List&lt;UserDTO&gt; encontrarTodos() {
        // cada elemento de la lista deberá ser
        // convertido en su dto.
        return repoUsuario.findAll().stream().map(usuario -&gt; DTOMapper.toDTO(usuario)).collect(Collectors.toList());

    }

    @Override
    public UserDTO encontrarPorId(Long id) {
        User usuario = repoUsuario.findById(id).orElse(null);
        // TODO Auto-generated method stub
        return DTOMapper.toDTO(usuario);
    }

    @Override
    public void eliminar(UserDTO user) {
        User usuario = DTOMapper.toEntity(user);
        repoUsuario.delete(usuario);
    }

    /**
     * Inicia la sesión, retornando un token en caso que sea exitoso o
     * retornando una exeption en caso de no ser exitoso.
     * 
     * La técnica es fabricar un objeto que implemente Authentication, en este caso
     * UsernamePasswordAuthenticationToken, una de sus implementaciones y la que
     * usaremos acá. Esta implementación requiere dos parámetros, un principal
     * que para nuestro caso es el username, y un credentials que es la
     * contraseña. Posee un tercer parámetro que no vemos y este es
     * setAutenticated(false). Es decir que se crea un objeto tipo
     * Authentication, con tres parámetros:
     * - principal: username
     * - credentials: password
     * - setAuthenticated(false)
     * 
     * Este objeto es pasado a authenticationManager.authenticate(), y pueden pasar 2 cosas.
     * La primera es que se logre hacer el inicio de sesión y siga la ejecución y la otra
     * es que no se pueda realizar la autenticación y se arroje un AuthenticationException
     * lo que hará que no se genere el token por que no se sigue ejecutando la aplicación
     * en ese contexto.
     * 
     * La generación del token es independiente a si se pudo o no iniciar sesión. Esta
     * generación se puede realizar con un usuario que no esté autenticado. Pero en el
     * ejemplo, como se arroja una excepción no se continúa con la ejecución y es por
     * este motivo que no llega a generarse el token.
     * 
     * El intento de inicio de sesión es interno, se deduce de los parámetros que
     * tenga asignados en la configuración de los parámetros que se mapean en la
     * base de datos, en este caso, tenemos que en la tabla user, hay un campo
     * username y un campo password, que este `authenticate` comparará con los campos
     * principal y credentials que en este caso son los `raw_username y raw_password`
     * aunque solamente en la base de datos esté la contraseña encriptada, el método
     * `authenticate` sabe como realizar una operación que indique que el `raw_password`
     * sea matemáticamente equivalente con nuestra contraseña en la base de datos.
     * 
     */
    @Override
    public String signin(String username, String password) {
        String token = &quot;&quot;;
        try {
            // llenamos el objeto de autenticación. en este caso se crea por defecto
            // con setAutenticated en falso. Setear esto en verdadero, es tarea de
            // authenticationManager, que al no poder realizar el match, arroja
            // un AuthenticationException. si no se retorna el token.
            Authentication objetoAutentificacion = new UsernamePasswordAuthenticationToken(username, password);
            // le decimos al administrador de authenticacion, que intente autenticar con el usuario dado.
            // si esto no es posible, en este punto se arroja una excepción. y nada más se ejecuta.
            authenticationManager.authenticate(objetoAutentificacion);

            User usuarioAutenticado = repoUsuario.findByUsername(username);
            // solamente si el usuario pasa la existencia correcta de sus credenciiales
            // llegaremos hasta este punto, es decir que el token no juega 
            // ningún papel en la validación de usuario, todo lo que puede
            // validar es un token.
            token = generaToken(usuarioAutenticado);

        } catch (AuthenticationException e) {
            throw new RestServiceException(&quot;username o password invalido&quot;, HttpStatus.UNPROCESSABLE_ENTITY);
        }

        return token;
    }

    /**
     * Registro de usuario en el sistema, ingresa un nuevo usuario en la base
     * de datos. Retorna el token para poder comenzar con las peticioines.
     * Quizás no sea una buena manera, quizás el token, solamente debería
     * ser entregado al momento de hacer un inicio de sesión; perso
     * así está implementado en el ejemplo.
     */
    @Override
    public String signup(UserDTO user) {
        String jwtToken = &quot;&quot;;
        boolean existeUsuario = repoUsuario.existsByUsername(user.getUsername());

        if (!existeUsuario) {
            User usuario = registraUsuario(user);
            jwtToken = generaToken(usuario);
        } else {
            String message = &quot;Username ya está en uso&quot;;
            HttpStatus httpStatus = HttpStatus.UNPROCESSABLE_ENTITY;
            throw new RestServiceException(message, httpStatus);
        }

        return jwtToken;
    }

    /**
    * Construye un `UserDetails` estático, con la información que se le proporcione.
    * En este caso, el nombre de usuario que venía como argumento y
    * la contraseña que está en la base de datos. Este proceso
    * es implementado ya que este único método, posee
    * acceso a la contraseña del usuario.
    *
    * La técnica usada es que cada método retorna un `UserBuilder`, hasta
    * llegar a `build()`, es cuando finalmente es convertido en
    * un `UserDetail`. 
    *
    **/
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        final User user = repoUsuario.findByUsername(username);
        if (user == null) {
            throw new UsernameNotFoundException(&quot;Usuario '&quot; + username + &quot;' no encontrado&quot;);
        }
        return org.springframework.security.core.userdetails.User//
                .withUsername(username).password(user.getPassword()).authorities(user.getRoles()).accountExpired(false)
                .accountLocked(false).credentialsExpired(false).disabled(false).build();
    }

    /**
     * Executa el ingreso de un usuario al sistema. 
     */
    private User registraUsuario(UserDTO userDto) {
        String rawPassword = userDto.getPassword();

        // uso de la referencia al objeto passwordEncoder
        // posee un método encode que implementa Spring
        // que toma el rawPassword y lo encripta.
        String contraseniaEncriptada = passwordEncoder.encode(rawPassword);         
        userDto.setPassword(contraseniaEncriptada);
        User usuario = DTOMapper.toEntity(userDto);
        repoUsuario.save(usuario);

        return usuario;
    }

    /**
     * Genera el token, usando el nombre de usuario y los
     * roles. (Usamos el usuario aunque se puede con
     * un usuarioDTO).
     */
    private String generaToken(User usuario) {
        String token = jwtTokenProvider.createToken(
            usuario.getUsername(),
            usuario.getRoles()
        );

        return token;
    }

}

</code></pre>

<h3 id="cllherreraprexception"><code>cl.lherrera.pr.exception</code></h3>
<p><code>Exception</code>, especialmente diseñada para mostrar un error en la solicitud, que incluirá un atributo nuevo, con la misión de almacenar el código de error, además del mensaje.</p>
<p>La llamamos muchas veces en la implementación de la seguridad del token.</p>
<p><strong><code>/produce-rest/src/main/java/cl/lherrera/pr/exception/RestServiceException.java</code></strong></p>
<pre><code class="java">package cl.lherrera.pr.exception;

import org.springframework.http.HttpStatus;

public class RestServiceException extends RuntimeException {

    private static final long serialVersionUID = 5037553749745142029L;

    private final String message;
    private final HttpStatus httpStatus;

    public RestServiceException(String message, HttpStatus httpStatus) {
        super();
        this.message = message;
        this.httpStatus = httpStatus;
    }

    @Override
    public String getMessage() {
        return message;
    }

    public HttpStatus getHttpStatus() {
        return httpStatus;
    }

}

</code></pre>

<h3 id="cllherreraprdto"><code>cl.lherrera.pr.dto</code></h3>
<p>Solo cambios para adaptar la actualización en la entidad.</p>
<p><code>/produce-rest/src/main/java/cl/lherrera/pr/dto/UserDTO.java</code></p>
<pre><code class="java">package cl.lherrera.pr.dto;

import java.util.List;

import cl.lherrera.pr.modelo.entity.Role;

public class UserDTO {
    private Long id;
    private String name;
    private String username;
    private String email;
    private String password;
    private List&lt;Role&gt; roles;

    public UserDTO(Long id, String name, String username, String email, String password, List&lt;Role&gt; roles) {
        super();
        this.id = id;
        this.name = name;
        this.username = username;
        this.email = email;
        this.password = password;
        this.roles = roles;
    }

    public UserDTO() {}

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public List&lt;Role&gt; getRoles() {
        return roles;
    }

    public void setRoles(List&lt;Role&gt; roles) {
        this.roles = roles;
    }

}

</code></pre>

<h3 id="cllherreraprcontroller"><code>cl.lherrera.pr.controller</code></h3>
<p><strong><code>/produce-rest/src/main/java/cl/lherrera/pr/controller/UserController.java</code></strong></p>
<p>Podemos ver que no hay muchos cambios, pero no está demás la versión final funcionando, aunque parezca que los cambios son solamente en documentación.</p>
<pre><code class="java">package cl.lherrera.pr.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import cl.lherrera.pr.dto.UserDTO;
import cl.lherrera.pr.servicio.UserService;

@RestController
@RequestMapping(&quot;/api/v1/users&quot;)
public class UserController {
    @Autowired
    private UserService userService;

    /**
     * Método encargado de hacer el login, ocupa el servicio signin.
     */
    @PostMapping(&quot;/signin&quot;)
    public String login(@RequestParam String username, @RequestParam String password) {
        return userService.signin(username, password);
    }

    /**
     * Registra un usuario, Realiza la tarea de ingreso.
     */
    @PostMapping(&quot;/signup&quot;)
    @ResponseStatus(HttpStatus.CREATED)
    public String signup(@RequestBody UserDTO userDTO) {
        return userService.signup(userDTO);
    }

    /**
     * Por defecto, la petición entrega una lista de los usuarios.
     */
    @GetMapping(path = { &quot;&quot;, &quot;/&quot; })
    @ResponseStatus(code = HttpStatus.OK)
    public List&lt;UserDTO&gt; findAll() {
        return userService.encontrarTodos();
    }

    /**
     * Encuentra un usuario por ID, es un servicio para cuando se necesite un
     * usuario en particular.
     */
    @GetMapping(path = &quot;/{id}&quot;)
    @ResponseStatus(code = HttpStatus.OK)
    public UserDTO findOne(@PathVariable Long id) {
        return userService.encontrarPorId(id);
    }

    /**
     * Servicio destinado a actualizar los datos de un usuario.
     */
    @PutMapping(path = { &quot;&quot;, &quot;/&quot; })
    @ResponseStatus(HttpStatus.OK)
    void update(@RequestBody UserDTO userDTO) {
        userService.actualizar(userDTO);
    }

    /**
     * Servicio destinado a eliminar a un usuario.
     */
    @DeleteMapping
    @ResponseStatus(HttpStatus.OK)
    void delete(@RequestBody UserDTO userDTO) {
        userService.eliminar(userDTO);
    }
}
</code></pre>

<h3 id="produce-restpomxml"><code>/produce-rest/pom.xml</code></h3>
<p>Adicionamos el soporte para <code>JWT</code>, herramientas que nos prestan toda clase de servicios implementados para la administración de tokens, como por ejemplo el crearlos, validarlos correctamente, entre otras.</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.7.RELEASE&lt;/version&gt;
        &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;cl.lherrera&lt;/groupId&gt;
    &lt;artifactId&gt;produce-rest&lt;/artifactId&gt;
    &lt;version&gt;20.0.0&lt;/version&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;
    &lt;name&gt;produce-rest&lt;/name&gt;
    &lt;description&gt;api mod5 uni5 lectura 2&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!-- SQLITE - SUPPORT --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.xerial&lt;/groupId&gt;
            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- SQLITE - SUPPORT # --&gt;
        &lt;!-- JWT - SUPPORT --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
            &lt;version&gt;0.9.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- JWT - SUPPORT # --&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;

</code></pre>

<hr />
<h2 id="todo">TODO</h2>
<hr />
<ul>
<li>Implementar otra aplicación con un formulario, que contenga un <code>back</code> y un <code>front</code>. Que solamente realice la validación y registro de usuarios.</li>
</ul>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../../../assets/javascripts/vendor.a0c4167b.min.js"></script>
      <script src="../../../../assets/javascripts/bundle.fb26dd1d.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../../../..",
          features: [],
          search: Object.assign({
            worker: "../../../../assets/javascripts/worker/search.37585f48.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>